/**
 * Controlador para la interfaz administrativa del sistema
 * SIMPLIFICADO - Solo consultas que funcionan con campos reales
 */

const Documento = require('../models/Documento');
const Matrizador = require('../models/Matrizador');
const EventoDocumento = require('../models/EventoDocumento');
const RegistroAuditoria = require('../models/RegistroAuditoria');
const { sequelize } = require('../config/database');
const { Op } = require('sequelize');
const moment = require('moment');
const { 
  obtenerTimestampEcuador,
  convertirRangoParaSQL,
  formatearTimestamp,
  formatearFechaSinHora,
  formatearValorMonetario
} = require('../utils/documentoUtils');

// NUEVO: Importar sistema de logging
const { logger, logDashboard, logQuery } = require('../utils/logger');

/**
 * Dashboard Administrativo EJECUTIVO PROFESIONAL
 * Dise침ado para proporcionar informaci칩n cr칤tica y tomar decisiones informadas
 */
exports.dashboard = async (req, res) => {
  try {
    // 游댌 INICIO DE DEBUGGING - Dashboard Ejecutivo
    logger.separator('DASHBOARD', 'DASHBOARD ADMIN EJECUTIVO PROFESIONAL');
    logger.start('DASHBOARD', 'cargarDashboardEjecutivo', {
      usuario: req.matrizador?.nombre || 'admin'
    });
    
    // ============== PROCESAR FILTROS DE PER칈ODO ==============
    const rango = req.query.rango || req.query.tipoPeriodo || 'mes';
    let fechaInicio, fechaFin, periodoTexto;
    
    // Establecer fechas seg칰n el rango seleccionado
    const hoy = moment().startOf('day');
    
    switch (rango) {
      case 'desde_inicio':
        // NUEVO: Mostrar todos los datos hist칩ricos
        fechaInicio = moment('2020-01-01').startOf('day'); // Fecha muy antigua para incluir todo
        fechaFin = moment().endOf('day');
        periodoTexto = 'Desde el Inicio (Todos los datos hist칩ricos)';
        break;
      case 'hoy':
        fechaInicio = hoy.clone();
        fechaFin = moment().endOf('day');
        periodoTexto = 'Hoy ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'ayer':
        fechaInicio = hoy.clone().subtract(1, 'days');
        fechaFin = hoy.clone().subtract(1, 'days').endOf('day');
        periodoTexto = 'Ayer ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'semana':
        fechaInicio = hoy.clone().startOf('week');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Esta semana (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'mes':
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'ultimo_mes':
        fechaInicio = hoy.clone().subtract(30, 'days');
        fechaFin = moment().endOf('day');
        periodoTexto = '칔ltimos 30 d칤as';
        break;
      case 'personalizado':
        fechaInicio = req.query.fechaInicio ? moment(req.query.fechaInicio).startOf('day') : hoy.clone().startOf('month');
        fechaFin = req.query.fechaFin ? moment(req.query.fechaFin).endOf('day') : moment().endOf('day');
        periodoTexto = 'Del ' + fechaInicio.format('DD/MM/YYYY') + ' al ' + fechaFin.format('DD/MM/YYYY');
        break;
      default:
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
    }
    
    // Formatear fechas para consultas SQL
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    const hoySQL = hoy.format('YYYY-MM-DD');
    
    // ============== ALERTAS CR칈TICAS EJECUTIVAS ==============
    const alertasCriticas = [];
    
    // Documentos atrasados m치s de 30 d칤as sin pagar
    const documentosAtrasados = await Documento.count({
      where: {
        estado_pago: 'pendiente',
        numero_factura: { [Op.not]: null },
        estado: { [Op.notIn]: ['eliminado', 'nota_credito'] },
        created_at: { [Op.lt]: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
      }
    });
    
    if (documentosAtrasados > 0) {
      alertasCriticas.push({
        tipo: 'danger',
        icono: 'fas fa-exclamation-triangle',
        titulo: `${documentosAtrasados} documentos atrasados +30 d칤as`,
        descripcion: 'Requieren gesti칩n de cobranza urgente',
        accion: '/admin/reportes/pendientes?antiguedad=30%2B'
      });
    }
    
    // Documentos listos para entrega hace m치s de 3 d칤as
    const documentosListosViejos = await Documento.count({
      where: {
        estado: 'listo_para_entrega',
        updated_at: { [Op.lt]: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000) }
      }
    });
    
    if (documentosListosViejos > 0) {
      alertasCriticas.push({
        tipo: 'warning',
        icono: 'fas fa-clock',
        titulo: `${documentosListosViejos} documentos listos sin entregar`,
        descripcion: 'M치s de 3 d칤as esperando entrega',
        accion: '/admin/documentos/listado?estado=listo_para_entrega'
      });
    }
    
    // Documentos sin matrizador asignado
    const documentosSinMatrizador = await Documento.count({
      where: {
        id_matrizador: null,
        estado: { [Op.in]: ['en_proceso', 'listo_para_entrega'] }
      }
    });
    
    if (documentosSinMatrizador > 0) {
      alertasCriticas.push({
        tipo: 'info',
        icono: 'fas fa-user-slash',
        titulo: `${documentosSinMatrizador} documentos sin asignar`,
        descripcion: 'Necesitan matrizador responsable',
        accion: '/admin/documentos/listado?idMatrizador='
      });
    }
    
    // ============== M칄TRICAS EJECUTIVAS PRINCIPALES CON FILTROS ==============
    
    // CORREGIDO: Aplicar filtros de fecha a todas las m칠tricas principales
    const whereBasePeriodo = {
      created_at: {
        [Op.between]: [fechaInicio.toDate(), fechaFin.toDate()]
      },
      estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
    };
    
    // Conteos b치sicos CON FILTROS DE PER칈ODO
    const totalDocumentos = await Documento.count({
      where: whereBasePeriodo
    });
    
    const enProceso = await Documento.count({
      where: { ...whereBasePeriodo, estado: 'en_proceso' }
    });
    
    const listoParaEntrega = await Documento.count({
      where: { ...whereBasePeriodo, estado: 'listo_para_entrega' }
    });
    
    const entregados = await Documento.count({
      where: { ...whereBasePeriodo, estado: 'entregado' }
    });
    
    // Documentos entregados hoy (mantener filtro espec칤fico de hoy)
    const entregadosHoy = await Documento.count({
      where: {
        estado: 'entregado',
        fecha_entrega: {
          [Op.gte]: hoy.toDate(),
          [Op.lt]: moment().endOf('day').toDate()
        }
      }
    });
    
    // ============== M칄TRICAS FINANCIERAS EJECUTIVAS CON FILTROS ==============
    
    // CORREGIDO: Usar filtros de per칤odo para todas las m칠tricas financieras
    // Esto permite que el dashboard muestre datos reales del per칤odo seleccionado
    
    // Pagos recibidos del per칤odo (dinero cobrado en documentos del per칤odo)
    const [ingresosPeriodoResult] = await sequelize.query(`
      SELECT COALESCE(SUM(CASE WHEN estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial') THEN valor_pagado ELSE 0 END), 0) as total
      FROM documentos
      WHERE created_at BETWEEN :fechaInicio AND :fechaFin
      AND estado NOT IN ('eliminado', 'nota_credito')
    `, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    const ingresosPeriodo = parseFloat(ingresosPeriodoResult.total);
    
    // CORREGIDO: Pagos recibidos hoy espec칤ficamente (dinero realmente cobrado HOY)
    const [ingresosHoyResult] = await sequelize.query(`
      SELECT COALESCE(SUM(valor_pagado), 0) as total
      FROM documentos
      WHERE DATE(fecha_ultimo_pago) = :hoy
      AND estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial')
      AND estado NOT IN ('eliminado', 'nota_credito')
    `, {
      replacements: { hoy: hoySQL },
      type: sequelize.QueryTypes.SELECT
    });
    const ingresosHoy = parseFloat(ingresosHoyResult.total);
    
    // CORREGIDO: Documentos cobrados del per칤odo
    const documentosCobradosPeriodo = await Documento.count({
      where: {
        ...whereBasePeriodo,
        estado_pago: { [Op.in]: ['pagado_completo', 'pagado_con_retencion', 'pago_parcial'] }
      }
    });

    // CORREGIDO: Documentos cobrados hoy (incluir pago_parcial)
    const documentosCobradosHoy = await Documento.count({
      where: {
        estado_pago: { [Op.in]: ['pagado_completo', 'pagado_con_retencion', 'pago_parcial'] },
        fecha_ultimo_pago: {
          [Op.gte]: hoy.toDate(),
          [Op.lt]: moment().endOf('day').toDate()
        }
      }
    });
    
    // Facturaci칩n del per칤odo (mantener l칩gica existente)
    const [facturacionPeriodoResult] = await sequelize.query(`
      SELECT COALESCE(SUM(valor_factura), 0) as total
      FROM documentos
      WHERE created_at BETWEEN :fechaInicio AND :fechaFin
      AND numero_factura IS NOT NULL
      AND estado NOT IN ('eliminado', 'nota_credito')
    `, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    const facturacionPeriodo = parseFloat(facturacionPeriodoResult.total);
    
    // CORREGIDO: Total pendiente de cobro POR PER칈ODO - f칩rmula matem치ticamente exacta
    // Pendiente real = Facturado - Pagado - Retenido
    let totalPendienteQuery, totalPendienteReplacements;
    
    if (rango === 'desde_inicio') {
      // Para "desde_inicio", usar c치lculo global
      totalPendienteQuery = `
        SELECT COALESCE(SUM(valor_factura - valor_pagado - COALESCE(valor_retenido, 0)), 0) as total
        FROM documentos
        WHERE numero_factura IS NOT NULL
        AND estado NOT IN ('eliminado', 'nota_credito')
        AND (valor_factura - valor_pagado - COALESCE(valor_retenido, 0)) > 0
      `;
      totalPendienteReplacements = {};
    } else {
      // Para otros rangos, filtrar por per칤odo de creaci칩n
      totalPendienteQuery = `
        SELECT COALESCE(SUM(valor_factura - valor_pagado - COALESCE(valor_retenido, 0)), 0) as total
        FROM documentos
        WHERE created_at BETWEEN :fechaInicio AND :fechaFin
        AND numero_factura IS NOT NULL
        AND estado NOT IN ('eliminado', 'nota_credito')
        AND (valor_factura - valor_pagado - COALESCE(valor_retenido, 0)) > 0
      `;
      totalPendienteReplacements = { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL };
    }
    
    const [totalPendienteResult] = await sequelize.query(totalPendienteQuery, {
      replacements: totalPendienteReplacements,
      type: sequelize.QueryTypes.SELECT
    });
    const totalPendiente = parseFloat(totalPendienteResult.total);
    
    // ============== RENDIMIENTO DEL EQUIPO (7 d칤as) ==============
    const equipoRendimiento = await sequelize.query(`
      SELECT 
        m.nombre,
        COUNT(d.id) as documentos_procesados,
        SUM(CASE WHEN d.estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial') THEN d.valor_pagado ELSE 0 END) as dinero_cobrado,
        SUM(CASE WHEN d.estado = 'entregado' THEN 1 ELSE 0 END) as documentos_entregados
      FROM matrizadores m
      LEFT JOIN documentos d ON m.id = d.id_matrizador
        AND d.updated_at >= :hace7Dias
        AND d.estado NOT IN ('eliminado', 'nota_credito')
      WHERE m.rol IN ('matrizador', 'caja_archivo') AND m.activo = true
      GROUP BY m.id, m.nombre
      ORDER BY documentos_procesados DESC
      LIMIT 5
    `, {
      replacements: { hace7Dias: moment().subtract(7, 'days').format('YYYY-MM-DD HH:mm:ss') },
      type: sequelize.QueryTypes.SELECT
    });
    
    // Formatear dinero cobrado
    equipoRendimiento.forEach(item => {
      item.dinero_cobrado = parseFloat(item.dinero_cobrado || 0).toFixed(2);
    });
    
    // ============== 칔LTIMOS PAGOS REGISTRADOS ==============
    const ultimosPagos = await Documento.findAll({
      where: {
        estadoPago: { [Op.in]: ['pagado_completo', 'pagado_con_retencion', 'pago_parcial'] },
        fechaUltimoPago: { [Op.not]: null },
        valorPagado: { [Op.not]: null, [Op.gt]: 0 }
      },
      attributes: [
        'id',
        'codigoBarras',
        'nombreCliente',
        'valorFactura',
        'valorPagado',
        'fechaUltimoPago',
        'metodoPago',
        'numeroFactura',
        'estadoPago'
      ],
      order: [['fechaUltimoPago', 'DESC']],
      limit: 8
    });
    
    // CORREGIDO: Formatear datos de 칰ltimos pagos para la vista con valores reales
    const ultimosPagosFormateados = ultimosPagos.map(pago => {
      const pagoData = pago.toJSON(); // Convertir a objeto plano
      return {
        id: pagoData.id,
        codigoBarras: pagoData.codigoBarras || 'N/A',
        nombreCliente: pagoData.nombreCliente || 'Cliente no especificado',
        valorFactura: pagoData.valorFactura ? parseFloat(pagoData.valorFactura).toFixed(2) : '0.00',
        valorPagado: pagoData.valorPagado ? parseFloat(pagoData.valorPagado).toFixed(2) : '0.00',
        fechaUltimoPago: pagoData.fechaUltimoPago,
        metodoPago: pagoData.metodoPago && pagoData.metodoPago !== 'pendiente' ? 
          pagoData.metodoPago.replace('_', ' ').toUpperCase() : 'EFECTIVO',
        numeroFactura: pagoData.numeroFactura || 'N/A',
        estadoPago: pagoData.estadoPago,
        esPagoParcial: pagoData.estadoPago === 'pago_parcial'
      };
    });
    
    // DEBUGGING TEMPORAL - LOGS PARA VERIFICAR DATOS
    console.log('=== DEBUG 칔LTIMOS PAGOS ===');
    console.log('Documentos pagados encontrados:', ultimosPagos.length);
    if (ultimosPagos.length > 0) {
      console.log('Primer pago (raw):', ultimosPagos[0].toJSON());
      console.log('Primer pago (formateado):', ultimosPagosFormateados[0]);
    }
    console.log('============================');
    
    // ============== 칔LTIMAS ENTREGAS REALIZADAS ==============
    const ultimasEntregas = await Documento.findAll({
      where: {
        estado: 'entregado',
        fechaEntrega: { [Op.not]: null } // CORREGIDO: usar camelCase
      },
      attributes: ['codigoBarras', 'nombreCliente', 'tipoDocumento', 'fechaEntrega'], // CORREGIDO: usar camelCase
      include: [{
        model: Matrizador,
        as: 'matrizador',
        attributes: ['nombre']
      }],
      order: [['fechaEntrega', 'DESC']], // CORREGIDO: usar camelCase
      limit: 5
    });
    
    // ============== DOCUMENTOS QUE REQUIEREN ATENCI칍N ==============
    const documentosUrgentes = await Documento.findAll({
      where: {
        estadoPago: 'pendiente', // CORREGIDO: usar camelCase
        numeroFactura: { [Op.not]: null }, // CORREGIDO: usar camelCase
        estado: { [Op.notIn]: ['eliminado', 'nota_credito'] },
        created_at: { [Op.lt]: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000) }
      },
      include: [{
        model: Matrizador,
        as: 'matrizador',
        attributes: ['nombre']
      }],
      order: [['created_at', 'ASC']],
      limit: 5
    });
    
    // ============== PREPARAR DATOS PARA LA VISTA ==============
    
    const dashboardData = {
      // Informaci칩n del per칤odo
      periodo: {
        rango: rango,
        fechaInicio: fechaInicio.format('YYYY-MM-DD'),
        fechaFin: fechaFin.format('YYYY-MM-DD'),
        periodoTexto,
        esHoy: rango === 'hoy',
        esAyer: rango === 'ayer',
        esSemana: rango === 'semana',
        esMes: rango === 'mes',
        esUltimoMes: rango === 'ultimo_mes',
        esPersonalizado: rango === 'personalizado'
      },
      
      // Alertas cr칤ticas
      alertasCriticas,
      
      // M칠tricas principales
      metricas: {
        totalDocumentos,
        enProceso,
        listoParaEntrega,
        entregados,
        entregadosHoy,
        documentosAtrasados,
        documentosUrgentes: documentosUrgentes.length
      },
      
      // M칠tricas financieras
      finanzas: {
        ingresosPeriodo: ingresosPeriodo.toFixed(2), // Pagos recibidos en el per칤odo
        ingresosHoy: ingresosHoy.toFixed(2), // Pagos recibidos hoy
        documentosCobradosPeriodo,
        documentosCobradosHoy,
        facturacionPeriodo: facturacionPeriodo.toFixed(2),
        totalPendiente: totalPendiente.toFixed(2)
      },
      
      // Rendimiento del equipo
      equipoRendimiento,
      
      // Actividad reciente
      ultimosPagos: ultimosPagosFormateados,
      ultimasEntregas,
      documentosUrgentes
    };
    
    logger.end('DASHBOARD', 'cargarDashboardEjecutivo', {
      exitoso: true,
      alertasCriticas: alertasCriticas.length,
      totalDocumentos,
      ingresosPeriodo
    });
    
    res.render('admin/dashboard', {
      layout: 'admin',
      title: 'Panel de Control Ejecutivo - ProNotary',
      activeDashboard: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      ...dashboardData
    });
    
  } catch (error) {
    logger.error('DASHBOARD', 'Error al cargar dashboard ejecutivo', error);
    res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Ha ocurrido un error al cargar el dashboard ejecutivo',
      error
    });
  }
};

/**
 * Funci칩n auxiliar para obtener datos de volumen de documentos para gr치fico
 * SIMPLIFICADA - Solo usar created_at
 */
async function obtenerDatosVolumen(fechaInicio, fechaFin) {
  // Determinar unidad de tiempo seg칰n rango de fechas
  const diffDays = Math.ceil((fechaFin - fechaInicio) / (1000 * 60 * 60 * 24));
  let unidadTiempo, formatoAgrupacion, formatoFecha;
  
  if (diffDays <= 1) {
    unidadTiempo = 'hour';
    formatoAgrupacion = "date_trunc('hour', created_at)";
    formatoFecha = "YYYY-MM-DD HH24:00";
  } else if (diffDays <= 31) {
    unidadTiempo = 'day';
    formatoAgrupacion = "date_trunc('day', created_at)";
    formatoFecha = "YYYY-MM-DD";
  } else if (diffDays <= 90) {
    unidadTiempo = 'week';
    formatoAgrupacion = "date_trunc('week', created_at)";
    formatoFecha = "YYYY-WW";
  } else {
    unidadTiempo = 'month';
    formatoAgrupacion = "date_trunc('month', created_at)";
    formatoFecha = "YYYY-MM";
  }
  
  // Consulta SQL para nuevos documentos por per칤odo (usar created_at = cuando se registraron)
  const datosNuevos = await sequelize.query(`
    SELECT 
      to_char(${formatoAgrupacion}, '${formatoFecha}') as fecha,
      COUNT(*) as total
    FROM documentos
    WHERE created_at BETWEEN :fechaInicio AND :fechaFin
    AND estado IN ('en_proceso', 'listo_para_entrega', 'entregado')
    GROUP BY ${formatoAgrupacion}
    ORDER BY ${formatoAgrupacion}
  `, {
    replacements: { fechaInicio, fechaFin },
    type: sequelize.QueryTypes.SELECT
  });
  
  // Consulta SQL para documentos entregados por per칤odo (usar fecha_entrega)
  const datosEntregados = await sequelize.query(`
    SELECT 
      to_char(${formatoAgrupacion.replace('created_at', 'fecha_entrega')}, '${formatoFecha}') as fecha,
      COUNT(*) as total
    FROM documentos
    WHERE estado = 'entregado'
      AND fecha_entrega BETWEEN :fechaInicio AND :fechaFin
    GROUP BY ${formatoAgrupacion.replace('created_at', 'fecha_entrega')}
    ORDER BY ${formatoAgrupacion.replace('created_at', 'fecha_entrega')}
  `, {
    replacements: { fechaInicio, fechaFin },
    type: sequelize.QueryTypes.SELECT
  });
  
  // Generar lista completa de fechas en el rango
  const fechas = [];
  const nuevos = [];
  const entregados = [];
  
  // Generar series de fechas seg칰n la unidad de tiempo
  let fechaActual = new Date(fechaInicio);
  while (fechaActual <= fechaFin) {
    let fecha;
    if (unidadTiempo === 'hour') {
      fecha = fechaActual.toISOString().substring(0, 13) + ":00";
      fechaActual.setHours(fechaActual.getHours() + 1);
    } else if (unidadTiempo === 'day') {
      fecha = fechaActual.toISOString().substring(0, 10);
      fechaActual.setDate(fechaActual.getDate() + 1);
    } else if (unidadTiempo === 'week') {
      const year = fechaActual.getFullYear();
      const onejan = new Date(year, 0, 1);
      const weekNum = Math.ceil(((fechaActual - onejan) / 86400000 + onejan.getDay() + 1) / 7);
      fecha = `${year}-W${weekNum.toString().padStart(2, '0')}`;
      fechaActual.setDate(fechaActual.getDate() + 7);
    } else {
      fecha = fechaActual.toISOString().substring(0, 7);
      fechaActual.setMonth(fechaActual.getMonth() + 1);
    }
    
    fechas.push(fecha);
    
    const nuevoItem = datosNuevos.find(item => item.fecha === fecha);
    nuevos.push(nuevoItem ? parseInt(nuevoItem.total) : 0);
    
    const entregadoItem = datosEntregados.find(item => item.fecha === fecha);
    entregados.push(entregadoItem ? parseInt(entregadoItem.total) : 0);
  }
  
  return {
    fechas,
    nuevos,
    entregados,
    unidadTiempo
  };
}

/**
 * Funci칩n auxiliar para obtener datos de documentos por matrizador
 * SIMPLIFICADA - Solo usar created_at
 */
async function obtenerDatosMatrizador(fechaInicio, fechaFin) {
  // Consulta SQL para documentos por matrizador (usar created_at para consistencia)
  const datos = await sequelize.query(`
    SELECT 
      m.id as id_matrizador,
      m.nombre as nombre_matrizador,
      COUNT(d.id) as total_documentos
    FROM documentos d
    LEFT JOIN matrizadores m ON d.id_matrizador = m.id
    WHERE d.created_at BETWEEN :fechaInicio AND :fechaFin
    AND d.estado IN ('en_proceso', 'listo_para_entrega', 'entregado')
    GROUP BY m.id, m.nombre
    ORDER BY total_documentos DESC
    LIMIT 10
  `, {
    replacements: { fechaInicio, fechaFin },
    type: sequelize.QueryTypes.SELECT
  });
  
  // Extraer nombres y totales para el gr치fico
  const nombres = datos.map(item => item.nombre_matrizador || 'Sin asignar');
  const documentos = datos.map(item => parseInt(item.total_documentos));
  
  return {
    nombres,
    documentos
  };
}

/**
 * Funci칩n auxiliar para obtener datos de documentos por tipo
 * SIMPLIFICADA - Solo usar created_at
 */
async function obtenerDatosTipoDocumento(fechaInicio, fechaFin) {
  // Consulta SQL para documentos por tipo (usar created_at para consistencia)
  const datos = await sequelize.query(`
    SELECT 
      tipo_documento,
      COUNT(*) as total
    FROM documentos
    WHERE created_at BETWEEN :fechaInicio AND :fechaFin
    AND estado IN ('en_proceso', 'listo_para_entrega', 'entregado')
    GROUP BY tipo_documento
    ORDER BY total DESC
  `, {
    replacements: { fechaInicio, fechaFin },
    type: sequelize.QueryTypes.SELECT
  });
  
  // Extraer tipos y totales para el gr치fico
  const nombres = datos.map(item => item.tipo_documento || 'Sin tipo');
  const documentos = datos.map(item => parseInt(item.total));
  
  return {
    nombres,
    documentos
  };
}

/**
 * Muestra la p치gina de reportes y estad칤sticas
 * CORREGIDO: Manejar diferentes tipos de reporte con el par치metro :tipo
 */
exports.reportes = async (req, res) => {
  try {
    // Obtener par치metros de filtro
    const tipo = req.params.tipo || req.query.tipo; // CORREGIDO: No asignar valor por defecto
    const fechaInicio = req.query.fechaInicio ? moment(req.query.fechaInicio).startOf('day') : moment().subtract(30, 'days').startOf('day');
    const fechaFin = req.query.fechaFin ? moment(req.query.fechaFin).endOf('day') : moment().endOf('day');
    const idMatrizador = req.query.idMatrizador || '';
    const estado = req.query.estado || '';
    const formato = req.query.formato || 'web'; // web o excel
    
    // Obtener matrizadores para filtros
    const matrizadores = await Matrizador.findAll({
      order: [['nombre', 'ASC']]
    });
    
    // NUEVO: Si no hay tipo espec칤fico, mostrar p치gina de 칤ndice de reportes
    if (!tipo) {
      return res.render('admin/reportes', {
        layout: 'admin',
        title: 'Reportes y Estad칤sticas',
        activeReportes: true,
        matrizadores,
        filtros: {
          rango: req.query.rango || 'mes',
          fechaInicio: fechaInicio.format('YYYY-MM-DD'),
          fechaFin: fechaFin.format('YYYY-MM-DD'),
          idMatrizador,
          estado
        },
        userRole: req.matrizador?.rol,
        userName: req.matrizador?.nombre
        // NO pasar vistaPartial para mostrar las tarjetas de reportes
      });
    }
    
    // Condiciones base para consultas (solo si hay tipo espec칤fico)
    const condiciones = {
      created_at: {
        [Op.between]: [fechaInicio.toDate(), fechaFin.toDate()]
      }
    };
    
    // A침adir filtros opcionales si est치n presentes en la URL
    if (idMatrizador) {
      condiciones.idMatrizador = idMatrizador;
    }
    
    if (estado) {
      condiciones.estado = estado;
    }
    
    let datosReporte = {}; // Objeto para almacenar los datos espec칤ficos del reporte
    let reporteTitulo = '';
    let vistaPartial = ''; // Partial a renderizar dentro de la p치gina principal

    // Generar reportes seg칰n el tipo seleccionado
    switch (tipo) {
      case 'estado':
        reporteTitulo = 'Reporte de Documentos por Estado';
        vistaPartial = 'admin/reportes/partials/estado';
        
        // L칩gica existente para reporte por estado
        const estadisticasEstado = await Documento.findAll({
          where: condiciones,
          attributes: [
            'estado',
            [sequelize.fn('COUNT', sequelize.col('Documento.id')), 'count']
          ],
          group: ['estado'],
          raw: true
        });
        
        const totalDocumentosEstado = estadisticasEstado.reduce((sum, item) => sum + parseInt(item.count), 0);
        
        datosReporte.resultados = estadisticasEstado.map(item => ({
          _id: item.estado,
          count: parseInt(item.count),
          porcentaje: Math.round((parseInt(item.count) / totalDocumentosEstado) * 100)
        }));
        
        datosReporte.totales = { count: totalDocumentosEstado };
        break;
        
      case 'matrizador':
        reporteTitulo = 'Reporte de Documentos por Matrizador';
        vistaPartial = 'admin/reportes/partials/matrizador';
        
        // L칩gica existente para reporte por matrizador
        const estadisticasMatrizador = await Documento.findAll({
          where: condiciones,
          attributes: [
            'idMatrizador',
            [sequelize.fn('COUNT', sequelize.col('Documento.id')), 'count']
          ],
          include: [{
            model: Matrizador,
            as: 'matrizador',
            attributes: ['nombre']
          }],
          group: ['idMatrizador', 'matrizador.id'],
          raw: true
        });
        
        const totalDocumentosMatrizador = estadisticasMatrizador.reduce((sum, item) => sum + parseInt(item.count), 0);
        
        datosReporte.resultados = estadisticasMatrizador.map(item => ({
          _id: item.idMatrizador,
          nombre: item['matrizador.nombre'] || 'Sin asignar',
          count: parseInt(item.count),
          porcentaje: totalDocumentosMatrizador > 0 ? Math.round((parseInt(item.count) / totalDocumentosMatrizador) * 100) : 0
        }));
        
        datosReporte.totales = { count: totalDocumentosMatrizador };
        break;
        
      case 'fecha':
        reporteTitulo = 'Reporte de Documentos por Fecha';
        vistaPartial = 'admin/reportes/partials/fecha';

        // L칩gica existente para reporte por fecha
        const documentosPorFecha = await Documento.findAll({
          where: condiciones,
          attributes: [
            [sequelize.fn('date', sequelize.col('created_at')), 'fecha'],
            [sequelize.fn('COUNT', sequelize.literal('CASE WHEN estado = \'en_proceso\' THEN 1 ELSE NULL END')), 'en_proceso'],
            [sequelize.fn('COUNT', sequelize.literal('CASE WHEN estado = \'listo_para_entrega\' THEN 1 ELSE NULL END')), 'listo_para_entrega'],
            [sequelize.fn('COUNT', sequelize.literal('CASE WHEN estado = \'entregado\' THEN 1 ELSE NULL END')), 'entregado'],
            [sequelize.fn('COUNT', sequelize.col('Documento.id')), 'total']
          ],
          group: [sequelize.fn('date', sequelize.col('created_at'))],
          order: [[sequelize.fn('date', sequelize.col('created_at')), 'ASC']],
          raw: true
        });
        
        datosReporte.resultados = documentosPorFecha.map(item => ({
          _id: item.fecha,
          registrados: parseInt(item.total),
          listos: parseInt(item.listo_para_entrega),
          entregados: parseInt(item.entregado)
        }));
        
        datosReporte.totales = {
          registrados: datosReporte.resultados.reduce((sum, item) => sum + item.registrados, 0),
          listos: datosReporte.resultados.reduce((sum, item) => sum + item.listos, 0),
          entregados: datosReporte.resultados.reduce((sum, item) => sum + item.entregados, 0)
        };
        break;
        
      case 'tipoDocumento':
        reporteTitulo = 'Reporte de Documentos por Tipo';
        vistaPartial = 'admin/reportes/partials/tipoDocumento';
        
        // L칩gica existente para reporte por tipo de documento
        const estadisticasTipo = await Documento.findAll({
          where: condiciones,
          attributes: [
            'tipo_documento',
            [sequelize.fn('COUNT', sequelize.col('Documento.id')), 'count']
          ],
          group: ['tipo_documento'],
          raw: true
        });
        
        const totalDocumentosTipo = estadisticasTipo.reduce((sum, item) => sum + parseInt(item.count), 0);
        
        datosReporte.resultados = estadisticasTipo.map(item => ({
          _id: item.tipo_documento,
          count: parseInt(item.count),
          porcentaje: Math.round((parseInt(item.count) / totalDocumentosTipo) * 100)
        }));
        
        datosReporte.totales = { count: totalDocumentosTipo };
        break;
        
      case 'sin_procesar': // Nuevo reporte: Documentos Sin Procesar (Supervisi칩n)
        reporteTitulo = 'Reporte: Documentos Sin Procesar';
        vistaPartial = 'admin/reportes/partials/sin_procesar';

        // Obtener documentos pendientes de procesamiento
        datosReporte.documentos = await Documento.findAll({
          where: {
            // Filtro: estado NO sea listo_para_entrega ni entregado
            estado: { [Op.notIn]: ['listo_para_entrega', 'entregado'] },
            // Aplicar filtros de fecha si est치n presentes
            created_at: condiciones.created_at,
            // Aplicar filtro de matrizador si est치 presente
            ...(idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '' && { id_matrizador: parseInt(idMatrizador, 10) })
          },
          include: [{
            model: Matrizador,
            as: 'matrizador',
            attributes: ['nombre']
          }],
          attributes: ['id', 'codigo_barras', 'tipo_documento', 'nombre_cliente', 'created_at', 'estado'],
          order: [['created_at', 'ASC']], // Ordenar por m치s antiguos primero
        });
        
        // Calcular d칤as desde registro para cada documento
        datosReporte.documentos = datosReporte.documentos.map(doc => ({
          ...doc.toJSON(),
          diasDesdeRegistro: moment().diff(moment(doc.created_at), 'days'),
          matrizadorNombre: doc.matrizador?.nombre || 'Sin asignar'
        }));
        
        // Estad칤sticas r치pidas por matrizador (sin procesar)
        const statsSinProcesar = await Documento.findAll({
          where: {
            estado: { [Op.notIn]: ['listo_para_entrega', 'entregado'] },
            created_at: condiciones.created_at,
             ...(idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '' && { id_matrizador: parseInt(idMatrizador, 10) })
          },
           attributes: [
            'id_matrizador',
            [sequelize.fn('COUNT', sequelize.col('Documento.id')), 'count'],
            [sequelize.fn('AVG', sequelize.literal('EXTRACT(DAY FROM NOW() - "Documento"."created_at")')), 'promedio_dias']
          ],
          include: [{
            model: Matrizador,
            as: 'matrizador',
            attributes: ['nombre']
          }],
          group: ['Documento.id_matrizador', 'matrizador.id'],
          order: [[sequelize.literal('count'), 'DESC']],
          raw: true
        });
        
        datosReporte.statsMatrizador = statsSinProcesar.map(item => ({
          nombre: item['matrizador.nombre'] || 'Sin asignar',
          cantidad: parseInt(item.count),
          promedio_dias: parseFloat(item.promedio_dias || 0).toFixed(1)
        }));
        
        datosReporte.totales = { totalDocumentos: datosReporte.documentos.length };

        break;

      case 'sin_pago': // Nuevo reporte: Documentos Sin Pago (Cobranza)
        reporteTitulo = 'Reporte: Documentos Sin Pago';
        vistaPartial = 'admin/reportes/partials/sin_pago';

        // Obtener documentos pendientes de pago
        datosReporte.documentos = await Documento.findAll({
          where: {
            // Filtro: estado_pago NO sea pagado
            estadoPago: { [Op.ne]: 'pagado' },
            // CORREGIDO: Usar created_at para el filtro de fechas, no fecha_factura
            created_at: condiciones.created_at,
            // Solo incluir documentos que tengan factura
            numeroFactura: { [Op.not]: null },
            valorFactura: { [Op.not]: null },
            // Aplicar filtro de matrizador si est치 presente
             ...(idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '' && { id_matrizador: parseInt(idMatrizador, 10) })
          },
          attributes: ['id', 'codigoBarras', 'tipoDocumento', 'nombreCliente', 'valorFactura', 'fechaFactura', 'estadoPago', 'created_at'],
          order: [['created_at', 'ASC']], // Ordenar por fecha de registro m치s antigua
        });

        // Calcular d칤as desde fecha de factura para cada documento
        datosReporte.documentos = datosReporte.documentos.map(doc => {
          const docJson = doc.toJSON();
          const diasDesdeFactura = docJson.fechaFactura ? moment().diff(moment(docJson.fechaFactura), 'days') : 'N/A';
          return {
            ...docJson,
            // CORREGIDO: Usar nombres camelCase que realmente vienen del toJSON()
            valor_factura_formato: docJson.valorFactura ? parseFloat(docJson.valorFactura).toFixed(2) : '0.00',
            fecha_factura_formato: docJson.fechaFactura ? moment(docJson.fechaFactura).format('DD/MM/YYYY') : 'Sin fecha',
            diasDesdeFactura,
            atrasado: diasDesdeFactura !== 'N/A' && diasDesdeFactura > 30,
            // Agregar campos en snake_case para compatibilidad con la vista
            codigo_barras: docJson.codigoBarras,
            tipo_documento: docJson.tipoDocumento,
            nombre_cliente: docJson.nombreCliente,
            valor_factura: docJson.valorFactura,
            fecha_factura: docJson.fechaFactura,
            estado_pago: docJson.estadoPago
          };
        });
        
        // Estad칤sticas r치pidas de montos pendientes
         const statsSinPago = await Documento.findAll({
          where: {
            estadoPago: { [Op.ne]: 'pagado' },
            created_at: condiciones.created_at,
            // Solo incluir documentos que tengan factura
            numeroFactura: { [Op.not]: null },
            valorFactura: { [Op.not]: null },
             ...(idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '' && { id_matrizador: parseInt(idMatrizador, 10) })
          },
           attributes: [
            [sequelize.fn('COUNT', sequelize.col('Documento.id')), 'count'],
            [sequelize.fn('SUM', sequelize.col('valor_factura')), 'total_valor']
          ],
          raw: true
        });

        datosReporte.statsGeneral = {
          totalDocumentos: parseInt(statsSinPago[0]?.count || 0),
          totalValor: parseFloat(statsSinPago[0]?.total_valor || 0).toFixed(2)
        };

        break;
        
      case 'financiero': // Reporte Financiero - redirigir a funci칩n espec칤fica
        return exports.reporteFinanciero(req, res);

      // Agregar otros casos para reportes futuros (ej. 'equipo')

      default:
        // Si el tipo no es reconocido, redirigir a la p치gina de 칤ndice
        return res.redirect('/admin/reportes');
    }
    
    // Renderizar la vista principal de reportes, pasando los datos espec칤ficos
    res.render('admin/reportes', { // CORREGIDO: Usar vista principal unificada
      layout: 'admin',
      title: reporteTitulo, // Usar el t칤tulo del reporte actual
      activeReportes: true,
      matrizadores, // Pasar lista completa de matrizadores para filtros
      filtros: {
        tipo,
        rango: req.query.rango || 'mes', // Mantener el rango seleccionado en los filtros
        fechaInicio: fechaInicio.format('YYYY-MM-DD'),
        fechaFin: fechaFin.format('YYYY-MM-DD'),
        idMatrizador,
        estado // Mantener estado si aplica
      },
      tipoReporteActual: tipo, // Pasar el tipo de reporte activo
      vistaPartial, // Pasar el nombre del partial a incluir
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      ...datosReporte // Pasar todos los datos espec칤ficos del reporte
    });

  } catch (error) {
    console.error('Error al generar reportes:', error);
    res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Ha ocurrido un error al generar los reportes',
      error
    });
  }
};

/**
 * Muestra los registros de auditor칤a de seguridad
 */
exports.verRegistrosAuditoria = async (req, res) => {
  try {
    // Par치metros de filtrado con fechas correctas
    const fechaInicio = req.query.fechaInicio ? new Date(req.query.fechaInicio) : new Date(new Date().setDate(new Date().getDate() - 7));
    const fechaFin = req.query.fechaFin ? new Date(req.query.fechaFin + 'T23:59:59') : new Date();
    const accion = req.query.accion || '';
    const resultado = req.query.resultado || '';
    const idMatrizador = req.query.idMatrizador || '';
    
    // Condiciones de filtrado
    const where = {
      created_at: {
        [Op.between]: [fechaInicio, fechaFin]
      }
    };
    
    if (accion) {
      where.accion = accion;
    }
    
    if (resultado) {
      where.resultado = resultado;
    }
    
    if (idMatrizador) {
      where.idMatrizador = idMatrizador;
    }
    
    // Obtener registros con paginaci칩n
    const page = parseInt(req.query.page) || 1;
    const limit = 50;
    const offset = (page - 1) * limit;
    
    const { count, rows: registros } = await RegistroAuditoria.findAndCountAll({
      where,
      include: [
        {
          model: Documento,
          as: 'documento',
          attributes: ['id', 'tipo_documento', 'codigo_barras', 'nombre_cliente']
        },
        {
          model: Matrizador,
          as: 'matrizador',
          attributes: ['id', 'nombre', 'rol']
        }
      ],
      order: [['created_at', 'DESC']],
      limit,
      offset
    });
    
    // Preparar datos para la paginaci칩n
    const totalPages = Math.ceil(count / limit);
    const pagination = {
      pages: []
    };
    
    // Generar enlaces de paginaci칩n
    for (let i = 1; i <= totalPages; i++) {
      pagination.pages.push({
        num: i,
        active: i === page
      });
    }
    
    // Obtener matrizadores para filtros
    const matrizadores = await Matrizador.findAll({
      order: [['nombre', 'ASC']]
    });
    
    // Tipos de acciones para filtros
    const tiposAccion = [
      { id: 'consulta_codigo', nombre: 'Consulta de c칩digo' },
      { id: 'verificacion_codigo', nombre: 'Verificaci칩n con c칩digo' },
      { id: 'verificacion_llamada', nombre: 'Verificaci칩n por llamada' },
      { id: 'edicion_codigo', nombre: 'Edici칩n de c칩digo' }
    ];
    
    res.render('admin/auditoria', {
      layout: 'admin',
      title: 'Registros de Auditor칤a',
      activeAuditoria: true,
      registros,
      pagination,
      matrizadores,
      tiposAccion,
      filtros: {
        fechaInicio: fechaInicio.toISOString().slice(0, 10),
        fechaFin: fechaFin.toISOString().slice(0, 10),
        accion,
        resultado,
        idMatrizador
      }
    });
  } catch (error) {
    console.error('Error al mostrar registros de auditor칤a:', error);
    res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Ha ocurrido un error al cargar los registros de auditor칤a',
      error
    });
  }
};

/**
 * Descarga un reporte exportado en formato PDF o Excel
 */
exports.descargarReporte = async (req, res) => {
  try {
    // Obtener par치metros
    const formato = req.query.formato || 'pdf';
    const contenidos = Array.isArray(req.query.contenido) ? req.query.contenido : [req.query.contenido];
    const tipoPeriodo = req.query.tipoPeriodo || 'hoy';
    
    // Procesar fechas usando utilidades centralizadas
    const ahora = obtenerTimestampEcuador();
    let fechaInicio, fechaFin;
    
    switch (tipoPeriodo) {
      case 'hoy':
        const rango = convertirRangoParaSQL(
          ahora.toISOString().split('T')[0], 
          ahora.toISOString().split('T')[0]
        );
        fechaInicio = rango.fechaInicioObj;
        fechaFin = rango.fechaFinObj;
        break;
      case 'semana':
        const inicioSemana = new Date(ahora);
        inicioSemana.setDate(inicioSemana.getDate() - inicioSemana.getDay());
        const rangoSemana = convertirRangoParaSQL(
          inicioSemana.toISOString().split('T')[0],
          ahora.toISOString().split('T')[0]
        );
        fechaInicio = rangoSemana.fechaInicioObj;
        fechaFin = rangoSemana.fechaFinObj;
        break;
      case 'mes':
        const inicioMes = new Date(ahora.getFullYear(), ahora.getMonth(), 1);
        const rangoMes = convertirRangoParaSQL(
          inicioMes.toISOString().split('T')[0],
          ahora.toISOString().split('T')[0]
        );
        fechaInicio = rangoMes.fechaInicioObj;
        fechaFin = rangoMes.fechaFinObj;
        break;
      case 'ultimo_mes':
        const hace30Dias = new Date(ahora);
        hace30Dias.setDate(hace30Dias.getDate() - 30);
        const rangoUltimoMes = convertirRangoParaSQL(
          hace30Dias.toISOString().split('T')[0],
          ahora.toISOString().split('T')[0]
        );
        fechaInicio = rangoUltimoMes.fechaInicioObj;
        fechaFin = rangoUltimoMes.fechaFinObj;
        break;
      case 'personalizado':
        const fechaInicioCustom = req.query.fechaInicio || hace30Dias.toISOString().split('T')[0];
        const fechaFinCustom = req.query.fechaFin || ahora.toISOString().split('T')[0];
        const rangoPersonalizado = convertirRangoParaSQL(fechaInicioCustom, fechaFinCustom);
        fechaInicio = rangoPersonalizado.fechaInicioObj;
        fechaFin = rangoPersonalizado.fechaFinObj;
        break;
      default:
        const rangoDefault = convertirRangoParaSQL(
          ahora.toISOString().split('T')[0], 
          ahora.toISOString().split('T')[0]
        );
        fechaInicio = rangoDefault.fechaInicioObj;
        fechaFin = rangoDefault.fechaFinObj;
    }
    
    // Formatear fechas para el nombre del archivo
    const fechaInicioStr = fechaInicio.toISOString().split('T')[0];
    const fechaFinStr = fechaFin.toISOString().split('T')[0];
    
    // Generar nombre del archivo
    const nombreArchivo = `reporte_documentos_${fechaInicioStr}_a_${fechaFinStr}`;
    
    // Preparar datos para el reporte
    const datos = {
      fechaInicio,
      fechaFin,
      fechaInicioStr,
      fechaFinStr,
      tipoPeriodo,
      resumen: contenidos.includes('resumen'),
      listado: contenidos.includes('listado'),
      matrizador: contenidos.includes('matrizador'),
      tipo: contenidos.includes('tipo')
    };
    
    // Obtener datos seg칰n el contenido solicitado
    if (datos.resumen) {
      // Estad칤sticas generales
      const total = await Documento.count();
      const enProceso = await Documento.count({ where: { estado: 'en_proceso' } });
      const listoParaEntrega = await Documento.count({ where: { estado: 'listo_para_entrega' } });
      const entregados = await Documento.count({ where: { estado: 'entregado' } });
      
      // Estad칤sticas del per칤odo (usar created_at)
      const nuevos = await Documento.count({
        where: {
          created_at: {
            [Op.between]: [fechaInicio, fechaFin]
          }
        }
      });
      
      const procesados = await EventoDocumento.count({
        where: {
          tipo: 'cambio_estado',
          detalles: {
            [Op.like]: '%listo_para_entrega%'
          },
          created_at: {
            [Op.between]: [fechaInicio, fechaFin]
          }
        }
      });
      
      const entregadosPeriodo = await Documento.count({
        where: {
          estado: 'entregado',
          fechaEntrega: {
            [Op.between]: [fechaInicio, fechaFin]
          }
        }
      });
      
      datos.estadisticas = {
        total,
        enProceso,
        listoParaEntrega,
        entregados,
        nuevos,
        procesados,
        entregadosPeriodo
      };
      
      // Tiempos promedio (usar campos correctos)
      const tiempoProcesamientoQuery = await sequelize.query(`
        SELECT AVG(EXTRACT(EPOCH FROM (e.created_at - d.created_at)) / 86400) as promedio_dias
        FROM "eventos_documentos" e
        JOIN "documentos" d ON e.id_documento = d.id
        WHERE e.tipo = 'cambio_estado'
        AND e.detalles LIKE '%listo_para_entrega%'
        AND e.created_at BETWEEN :fechaInicio AND :fechaFin
        AND d.estado IN ('en_proceso', 'listo_para_entrega', 'entregado')
      `, {
        replacements: { fechaInicio, fechaFin },
        type: sequelize.QueryTypes.SELECT
      });
      
      const tiempoEntregaQuery = await sequelize.query(`
        SELECT AVG(EXTRACT(EPOCH FROM (d.fecha_entrega - e.created_at)) / 86400) as promedio_dias
        FROM "documentos" d
        JOIN "eventos_documentos" e ON d.id = e.id_documento
        WHERE d.estado = 'entregado'
        AND e.tipo = 'cambio_estado'
        AND e.detalles LIKE '%listo_para_entrega%'
        AND d.fecha_entrega BETWEEN :fechaInicio AND :fechaFin
      `, {
        replacements: { fechaInicio, fechaFin },
        type: sequelize.QueryTypes.SELECT
      });
      
      datos.estadisticas.tiempoPromedioProcesamiento = tiempoProcesamientoQuery[0]?.promedio_dias 
        ? parseFloat(tiempoProcesamientoQuery[0].promedio_dias).toFixed(1) 
        : 'N/A';
      
      datos.estadisticas.tiempoPromedioEntrega = tiempoEntregaQuery[0]?.promedio_dias 
        ? parseFloat(tiempoEntregaQuery[0].promedio_dias).toFixed(1) 
        : 'N/A';
    }
    
    if (datos.listado) {
      // Listado detallado de documentos (usar created_at)
      datos.documentos = await Documento.findAll({
        where: {
          created_at: {
            [Op.between]: [fechaInicio, fechaFin]
          }
        },
        include: [{
          model: Matrizador,
          as: 'matrizador',
          attributes: ['id', 'nombre']
        }],
        order: [['created_at', 'DESC']]
      });
    }
    
    if (datos.matrizador) {
      // Estad칤sticas por matrizador
      datos.estadisticasMatrizador = await obtenerDatosMatrizador(fechaInicio, fechaFin);
    }
    
    if (datos.tipo) {
      // Estad칤sticas por tipo de documento
      datos.estadisticasTipo = await obtenerDatosTipoDocumento(fechaInicio, fechaFin);
    }
    
    // Generar reporte seg칰n formato solicitado
    if (formato === 'excel') {
      // TODO: Implementar exportaci칩n Excel usando exceljs
      // Por ahora, enviamos un JSON como respuesta temporal
      res.attachment(`${nombreArchivo}.json`);
      return res.json(datos);
    } else {
      // TODO: Implementar exportaci칩n PDF usando pdfkit o similar
      // Por ahora, enviamos un JSON como respuesta temporal
      res.attachment(`${nombreArchivo}.json`);
      return res.json(datos);
    }
  } catch (error) {
    console.error('Error al generar reporte:', error);
    res.status(500).send('Error al generar el reporte: ' + error.message);
  }
};

/**
 * TRANSFERIDO DESDE CAJA: Reporte detallado de documentos
 * Solo para administradores - informaci칩n sensible
 */
exports.reporteDocumentos = async (req, res) => {
  try {
    // Procesar par치metros de filtrado
    const rango = req.query.rango || 'mes';
    let fechaInicio, fechaFin, periodoTexto;
    
    // Establecer fechas seg칰n el rango seleccionado
    const hoy = moment().startOf('day');
    
    switch (rango) {
      case 'desde_inicio':
        // NUEVO: Mostrar todos los datos hist칩ricos
        fechaInicio = moment('2020-01-01').startOf('day'); // Fecha muy antigua para incluir todo
        fechaFin = moment().endOf('day');
        periodoTexto = 'Desde el Inicio (Todos los datos hist칩ricos)';
        break;
      case 'hoy':
        fechaInicio = hoy.clone();
        fechaFin = moment().endOf('day');
        periodoTexto = 'Hoy ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'ayer':
        fechaInicio = hoy.clone().subtract(1, 'days');
        fechaFin = hoy.clone().subtract(1, 'days').endOf('day');
        periodoTexto = 'Ayer ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'semana':
        fechaInicio = hoy.clone().startOf('week');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Esta semana (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'mes':
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'ultimo_mes':
        fechaInicio = hoy.clone().subtract(30, 'days');
        fechaFin = moment().endOf('day');
        periodoTexto = '칔ltimos 30 d칤as';
        break;
      case 'personalizado':
        fechaInicio = req.query.fechaInicio ? moment(req.query.fechaInicio).startOf('day') : hoy.clone().startOf('month');
        fechaFin = req.query.fechaFin ? moment(req.query.fechaFin).endOf('day') : moment().endOf('day');
        periodoTexto = 'Del ' + fechaInicio.format('DD/MM/YYYY') + ' al ' + fechaFin.format('DD/MM/YYYY');
        break;
      default:
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
    }
    
    // Formatear fechas para consultas SQL
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    
    // Obtener estad칤sticas de documentos
    const [statsResult] = await sequelize.query(`
      SELECT 
        COUNT(*) as total_documentos,
        COUNT(CASE WHEN numero_factura IS NOT NULL THEN 1 END) as con_factura,
        COUNT(CASE WHEN estado_pago = 'pendiente' THEN 1 END) as pendientes,
        COUNT(CASE WHEN estado_pago IN ('pagado_completo', 'pagado_con_retencion') THEN 1 END) as pagados,
        COALESCE(SUM(valor_factura), 0) as total_facturado,
        CASE 
          WHEN COUNT(*) > 0 THEN COALESCE(AVG(valor_factura), 0)
          ELSE 0
        END as promedio_facturado
      FROM documentos
      WHERE created_at BETWEEN :fechaInicio AND :fechaFin
        AND estado NOT IN ('eliminado', 'nota_credito')
    `, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    
    // Obtener estad칤sticas por tipo de documento
    const estadisticasPorTipo = await sequelize.query(`
      SELECT 
        tipo_documento as "tipoDocumento", 
        COUNT(*) as cantidad, 
        COALESCE(SUM(valor_factura), 0) as "totalFacturado",
        CASE 
          WHEN COUNT(*) > 0 THEN COALESCE(AVG(valor_factura), 0)
          ELSE 0
        END as promedio
      FROM documentos
      WHERE created_at BETWEEN :fechaInicio AND :fechaFin
        AND estado NOT IN ('eliminado', 'nota_credito')
      GROUP BY tipo_documento
      ORDER BY cantidad DESC
    `, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    
    // Calcular porcentajes para las estad칤sticas
    const totalDocumentos = parseInt(statsResult.total_documentos);
    const conFactura = parseInt(statsResult.con_factura);
    const pendientes = parseInt(statsResult.pendientes);
    const pagados = parseInt(statsResult.pagados);
    
    const porcentajeFacturados = totalDocumentos > 0 ? Math.round((conFactura / totalDocumentos) * 100) : 0;
    const porcentajePendientes = totalDocumentos > 0 ? Math.round((pendientes / totalDocumentos) * 100) : 0;
    const porcentajePagados = totalDocumentos > 0 ? Math.round((pagados / totalDocumentos) * 100) : 0;
    
    // Renderizar la vista con los datos
    res.render('admin/reportes/documentos', {
      layout: 'admin',
      title: 'Reporte de Documentos',
      activeReportes: true,
      stats: {
        totalDocumentos,
        conFactura,
        pendientes,
        pagados,
        totalFacturado: parseFloat(statsResult.total_facturado).toFixed(2),
        promedioFacturado: parseFloat(statsResult.promedio_facturado).toFixed(2),
        porcentajeFacturados,
        porcentajePendientes,
        porcentajePagados
      },
      estadisticasPorTipo,
      periodoTexto,
      filtros: {
        rango,
        fechaInicio: fechaInicio.format('YYYY-MM-DD'),
        fechaFin: fechaFin.format('YYYY-MM-DD')
      }
    });
  } catch (error) {
    console.error('Error al generar reporte de documentos:', error);
    return res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Error al generar el reporte de documentos',
      error
    });
  }
};

/**
 * TRANSFERIDO DESDE CAJA: Reporte de documentos pendientes
 * Solo para administradores - informaci칩n sensible sobre cobranza
 */
exports.reportePendientesAdmin = async (req, res) => {
  try {
    // Obtener par치metros de filtrado
    const { antiguedad, matrizador, ordenar, page = 1 } = req.query;
    const limit = 50;
    const offset = (page - 1) * limit;
    
    // Construir condiciones de filtrado
    const whereConditions = {
      estado_pago: 'pendiente',
      numero_factura: { [Op.not]: null },
      estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
    };
    
    if (matrizador) {
      whereConditions.id_matrizador = matrizador;
    }
    
    // Construir ORDER BY seg칰n el filtro
    let order = [['created_at', 'ASC']]; // Por defecto m치s antiguos
    if (ordenar === 'monto') {
      order = [['valor_factura', 'DESC']];
    } else if (ordenar === 'fecha') {
      order = [['created_at', 'DESC']];
    }
    
    // Obtener documentos pendientes
    const { count, rows: documentosPendientes } = await Documento.findAndCountAll({
      where: whereConditions,
      include: [{
        model: Matrizador,
        as: 'matrizador',
        attributes: ['id', 'nombre']
      }],
      order,
      limit,
      offset
    });
    
    // Calcular estad칤sticas por rangos de antig칲edad
    const statsQuery = `
      SELECT 
        COUNT(CASE WHEN EXTRACT(DAY FROM NOW() - COALESCE(fecha_factura::timestamp, created_at)) BETWEEN 1 AND 7 THEN 1 END) as rango1_7,
        COUNT(CASE WHEN EXTRACT(DAY FROM NOW() - COALESCE(fecha_factura::timestamp, created_at)) BETWEEN 8 AND 15 THEN 1 END) as rango8_15,
        COUNT(CASE WHEN EXTRACT(DAY FROM NOW() - COALESCE(fecha_factura::timestamp, created_at)) BETWEEN 16 AND 60 THEN 1 END) as rango16_60,
        COUNT(CASE WHEN EXTRACT(DAY FROM NOW() - COALESCE(fecha_factura::timestamp, created_at)) > 60 THEN 1 END) as rango60,
        SUM(CASE WHEN EXTRACT(DAY FROM NOW() - COALESCE(fecha_factura::timestamp, created_at)) BETWEEN 1 AND 7 THEN valor_factura ELSE 0 END) as monto1_7,
        SUM(CASE WHEN EXTRACT(DAY FROM NOW() - COALESCE(fecha_factura::timestamp, created_at)) BETWEEN 8 AND 15 THEN valor_factura ELSE 0 END) as monto8_15,
        SUM(CASE WHEN EXTRACT(DAY FROM NOW() - COALESCE(fecha_factura::timestamp, created_at)) BETWEEN 16 AND 60 THEN valor_factura ELSE 0 END) as monto16_60,
        SUM(CASE WHEN EXTRACT(DAY FROM NOW() - COALESCE(fecha_factura::timestamp, created_at)) > 60 THEN valor_factura ELSE 0 END) as monto60,
        COUNT(*) as totalPendientes
      FROM documentos
      WHERE estado_pago = 'pendiente'
      AND numero_factura IS NOT NULL
      AND estado NOT IN ('eliminado', 'nota_credito')
      ${matrizador ? `AND id_matrizador = ${matrizador}` : ''}
    `;
    
    const stats = await sequelize.query(statsQuery, {
      type: sequelize.QueryTypes.SELECT
    });
    
    const statsResult = stats[0];
    
    // Obtener lista de matrizadores para filtros
    const matrizadores = await Matrizador.findAll({
      where: {
        rol: 'matrizador',
        activo: true
      },
      attributes: ['id', 'nombre'],
      order: [['nombre', 'ASC']]
    });
    
    // Agregar d칤as de antig칲edad a cada documento
    const documentosConDatos = documentosPendientes.map(doc => {
      // CORREGIDO: Usar fecha_factura para calcular d칤as de atraso (no created_at)
      // Si no hay fecha_factura, usar created_at como fallback
      const fechaBase = doc.fechaFactura || doc.created_at;
      const diasAntiguedad = moment().diff(moment(fechaBase), 'days');
      return {
        ...doc.toJSON(),
        diasAntiguedad,
        matrizador: doc.matrizador?.nombre || 'Sin asignar'
      };
    });
    
    // Renderizar la vista con los datos
    res.render('admin/reportes/pendientes', {
      layout: 'admin',
      title: 'Reporte de Pagos Atrasados',
      activeReportes: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      documentosPendientes: documentosConDatos,
      stats: {
        rango1_7: parseInt(statsResult.rango1_7) || 0,
        rango8_15: parseInt(statsResult.rango8_15) || 0,
        rango16_60: parseInt(statsResult.rango16_60) || 0,
        rango60: parseInt(statsResult.rango60) || 0,
        monto1_7: parseFloat(statsResult.monto1_7) || 0,
        monto8_15: parseFloat(statsResult.monto8_15) || 0,
        monto16_60: parseFloat(statsResult.monto16_60) || 0,
        monto60: parseFloat(statsResult.monto60) || 0,
        totalPendientes: parseInt(statsResult.totalPendientes) || 0
      },
      matrizadores,
      filtros: {
        antiguedad,
        matrizador,
        ordenar
      }
    });
  } catch (error) {
    console.error('Error al generar reporte de documentos pendientes:', error);
    return res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Error al generar el reporte de documentos pendientes',
      error
    });
  }
};

/**
 * TRANSFERIDO DESDE CAJA: Reporte de productividad por matrizador
 * Solo para administradores - informaci칩n sensible sobre rendimiento
 */
exports.reporteMatrizadores = async (req, res) => {
  try {
    // Procesar par치metros
    const fechaInicio = req.query.fechaInicio ? moment(req.query.fechaInicio).startOf('day') : moment().subtract(30, 'days').startOf('day');
    const fechaFin = req.query.fechaFin ? moment(req.query.fechaFin).endOf('day') : moment().endOf('day');
    
    // Formatear fechas para SQL
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    
    // Obtener datos por matrizador
    const datosMatrizadores = await sequelize.query(`
      SELECT 
        m.id,
        m.nombre,
        COUNT(d.id) as documentos_totales,
        SUM(CASE WHEN d.estado_pago IN ('pagado_completo', 'pagado_con_retencion') THEN 1 ELSE 0 END) as documentos_pagados,
        SUM(CASE WHEN d.estado_pago = 'pendiente' THEN 1 ELSE 0 END) as documentos_pendientes,
        COALESCE(SUM(d.valor_factura), 0) as facturacion_total,
        COALESCE(SUM(CASE WHEN d.estado_pago IN ('pagado_completo', 'pagado_con_retencion') THEN d.valor_factura ELSE 0 END), 0) as ingresos_cobrados
      FROM matrizadores m
      LEFT JOIN documentos d ON m.id = d.id_matrizador
        AND d.created_at BETWEEN :fechaInicio AND :fechaFin
        AND d.estado NOT IN ('eliminado', 'nota_credito')
      WHERE m.rol IN ('matrizador', 'caja_archivo')
      GROUP BY m.id, m.nombre
      ORDER BY facturacion_total DESC
    `, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    
    // Calcular porcentajes y promedios
    datosMatrizadores.forEach(item => {
      item.porcentaje_pagados = item.documentos_totales > 0 ? 
        (item.documentos_pagados / item.documentos_totales * 100).toFixed(2) : 0;
      
      item.factura_promedio = item.documentos_totales > 0 ? 
        (item.facturacion_total / item.documentos_totales).toFixed(2) : 0;
        
      item.pendiente_cobro = (item.facturacion_total - item.ingresos_cobrados).toFixed(2);
    });
    
    // Renderizar el reporte
    res.render('admin/reportes/matrizadores', {
      layout: 'admin',
      title: 'Productividad por Matrizador',
      activeReportes: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      fechaInicio: fechaInicio.format('YYYY-MM-DD'),
      fechaFin: fechaFin.format('YYYY-MM-DD'),
      datosMatrizadores
    });
  } catch (error) {
    console.error('Error al generar reporte de matrizadores:', error);
    return res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Error al generar el reporte de matrizadores',
      error
    });
  }
};

/**
 * TRANSFERIDO DESDE CAJA: Reporte financiero con gr치ficos y an치lisis de per칤odos
 * Solo para administradores - informaci칩n financiera completa
 */
exports.reporteFinanciero = async (req, res) => {
  try {
    // Procesar par치metros de filtrado
    const rango = req.query.rango || 'mes';
    const idMatrizador = req.query.idMatrizador; // Leer el idMatrizador del query
    let fechaInicio, fechaFin, periodoTexto;
    
    // Establecer fechas seg칰n el rango seleccionado
    const hoy = moment().startOf('day');
    
    switch (rango) {
      case 'desde_inicio':
        // NUEVO: Mostrar todos los datos hist칩ricos
        fechaInicio = moment('2020-01-01').startOf('day'); // Fecha muy antigua para incluir todo
        fechaFin = moment().endOf('day');
        periodoTexto = 'Desde el Inicio (Todos los datos hist칩ricos)';
        break;
      case 'hoy':
        fechaInicio = hoy.clone();
        fechaFin = moment().endOf('day');
        periodoTexto = 'Hoy ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'ayer':
        fechaInicio = hoy.clone().subtract(1, 'days');
        fechaFin = hoy.clone().subtract(1, 'days').endOf('day');
        periodoTexto = 'Ayer ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'semana':
        fechaInicio = hoy.clone().startOf('week');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Esta semana (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'mes':
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'ultimo_mes':
        fechaInicio = hoy.clone().subtract(30, 'days');
        fechaFin = moment().endOf('day');
        periodoTexto = '칔ltimos 30 d칤as';
        break;
      case 'personalizado':
        fechaInicio = req.query.fechaInicio ? moment(req.query.fechaInicio).startOf('day') : hoy.clone().startOf('month');
        fechaFin = req.query.fechaFin ? moment(req.query.fechaFin).endOf('day') : moment().endOf('day');
        periodoTexto = 'Del ' + fechaInicio.format('DD/MM/YYYY') + ' al ' + fechaFin.format('DD/MM/YYYY');
        break;
      default:
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
    }
    
    // Formatear fechas para consultas SQL
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    
    // Obtener estad칤sticas financieras generales usando Sequelize ORM
    const whereClause = {
      valor_factura: { [Op.not]: null }, // CORREGIDO: usar snake_case como en DB
      estado: { [Op.ne]: 'cancelado' },
      created_at: {
        [Op.between]: [fechaInicioSQL, fechaFinSQL]
      }
    };
    
    // A침adir filtro por matrizador si se seleccion칩 uno
    if (idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '') {
      whereClause.id_matrizador = parseInt(idMatrizador, 10); // CORREGIDO: usar snake_case como en DB
    }
    
    const totalFacturado = await Documento.sum('valor_factura', { // CORREGIDO: usar snake_case como en DB
      where: whereClause
    }) || 0;
    
    const totalCobrado = await Documento.sum('valor_pagado', { // CORREGIDO: usar valor_pagado real
      where: {
        ...whereClause,
        estado_pago: { [Op.in]: ['pagado_completo', 'pagado_con_retencion', 'pago_parcial'] } // CORREGIDO: incluir pago_parcial
      }
    }) || 0;
    
    const totalPendiente = totalFacturado - totalCobrado;
    
    // Calcular porcentaje de recuperaci칩n
    const porcentajeRecuperacion = totalFacturado > 0 ? 
      Math.round((totalCobrado / totalFacturado) * 100) : 0;
    
    // CORREGIDO: Obtener datos diarios usando la misma l칩gica que funciona en caja
    const documentosPorDia = await Documento.findAll({
      where: whereClause,
      attributes: [
        [sequelize.fn('DATE', sequelize.col('created_at')), 'fecha'],
        [sequelize.fn('SUM', sequelize.col('valor_factura')), 'totalFacturado'], // CORREGIDO: usar snake_case como en DB
        [sequelize.fn('SUM', 
          sequelize.literal("CASE WHEN estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial') THEN valor_pagado ELSE 0 END") // CORREGIDO: usar valor_pagado e incluir pago_parcial
        ), 'totalCobrado']
      ],
      group: [sequelize.fn('DATE', sequelize.col('created_at'))],
      order: [[sequelize.fn('DATE', sequelize.col('created_at')), 'ASC']],
      raw: true
    });
    
    // Preparar datos para la tabla
    const datosTabla = documentosPorDia.map(item => {
      const facturado = parseFloat(item.totalFacturado) || 0;
      const cobrado = parseFloat(item.totalCobrado) || 0;
      const pendiente = facturado - cobrado;
      const porcentaje = facturado > 0 ? Math.round((cobrado / facturado) * 100) : 0;
      
      return {
        fecha: moment(item.fecha).format('DD/MM/YYYY'),
        facturado: facturado.toFixed(2),
        cobrado: cobrado.toFixed(2),
        pendiente: pendiente.toFixed(2),
        porcentaje: porcentaje
      };
    });
    
    // Preparar datos para el gr치fico de tendencia
    const graficoTendencia = {
      fechas: documentosPorDia.map(item => moment(item.fecha).format('DD/MM/YYYY')),
      facturado: documentosPorDia.map(item => parseFloat(item.totalFacturado) || 0),
      cobrado: documentosPorDia.map(item => parseFloat(item.totalCobrado) || 0),
      pendiente: documentosPorDia.map(item => 
        (parseFloat(item.totalFacturado) || 0) - (parseFloat(item.totalCobrado) || 0)
      )
    };
    
    // Obtener todos los matrizadores para el dropdown
    const matrizadores = await Matrizador.findAll({
      where: {
        rol: {
          [Op.in]: ['matrizador', 'caja_archivo']
        },
        activo: true
      },
      attributes: ['id', 'nombre'],
      order: [['nombre', 'ASC']]
    });
    
    // Renderizar la vista con los datos
    res.render('admin/reportes/financiero', { // CORREGIDO: usar vista admin
      layout: 'admin', // CORREGIDO: usar layout admin
      title: 'Reporte Financiero',
      activeReportes: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      matrizadores, // Pasar lista de matrizadores
      idMatrizadorSeleccionado: idMatrizador || 'todos', // Pasar ID seleccionado
      stats: {
        totalFacturado: formatearValorMonetario(totalFacturado),
        totalCobrado: formatearValorMonetario(totalCobrado),
        totalPendiente: formatearValorMonetario(totalPendiente),
        porcentajeRecuperacion
      },
      datosTabla,
      graficoTendencia,
      filtros: {
        rango,
        fechaInicio: fechaInicio.format('YYYY-MM-DD'),
        fechaFin: fechaFin.format('YYYY-MM-DD'),
        idMatrizador: idMatrizador || 'todos'
      },
      periodoTexto
    });
  } catch (error) {
    console.error('Error al generar reporte financiero:', error);
    return res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Error al generar el reporte financiero',
      error
    });
  }
};

/**
 * Reporte de Registros de Auditor칤a
 * Muestra el historial de acciones importantes del sistema
 */
exports.reporteRegistrosAuditoria = async (req, res) => {
  try {
    // Procesar par치metros de filtrado
    const fechaInicio = req.query.fechaInicio ? moment(req.query.fechaInicio).startOf('day') : moment().subtract(7, 'days').startOf('day');
    const fechaFin = req.query.fechaFin ? moment(req.query.fechaFin).endOf('day') : moment().endOf('day');
    const tipoAccion = req.query.tipoAccion;
    const usuario = req.query.usuario;
    const page = parseInt(req.query.page) || 1;
    const limit = 50;
    const offset = (page - 1) * limit;
    
    // Formatear fechas para SQL
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    
    // Construir filtros adicionales
    let whereFilters = '';
    const replacements = { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL };
    
    if (tipoAccion && tipoAccion !== 'todos') {
      whereFilters += ' AND accion LIKE :tipoAccion';
      replacements.tipoAccion = `%${tipoAccion}%`;
    }
    
    if (usuario && usuario !== 'todos') {
      whereFilters += ' AND usuario_nombre LIKE :usuario';
      replacements.usuario = `%${usuario}%`;
    }
    
    // Consulta principal de auditor칤a (simulada con datos de documentos)
    const auditoriaQuery = `
      SELECT 
        d.id,
        d.codigo_barras,
        d.tipo_documento,
        d.nombre_cliente,
        d.estado,
        d.estado_pago,
        d.created_at as fecha_accion,
        d.updated_at as fecha_modificacion,
        m.nombre as usuario_nombre,
        m.rol as usuario_rol,
        CASE 
          WHEN d.created_at = d.updated_at THEN 'CREACI칍N'
          WHEN d.estado = 'listo_para_entrega' THEN 'PROCESAMIENTO_COMPLETADO'
          WHEN d.estado = 'entregado' THEN 'ENTREGA'
          WHEN d.estado_pago IN ('pagado_completo', 'pagado_con_retencion') THEN 'PAGO_REGISTRADO'
          WHEN d.estado = 'cancelado' THEN 'CANCELACI칍N'
          ELSE 'MODIFICACI칍N'
        END as accion,
        d.valor_factura,
        d.numero_factura
      FROM documentos d
      JOIN matrizadores m ON d.id_matrizador = m.id
      WHERE d.updated_at BETWEEN :fechaInicio AND :fechaFin
      AND d.estado NOT IN ('eliminado')
      ${whereFilters}
      
      UNION ALL
      
      SELECT 
        NULL as id,
        NULL as codigo_barras,
        'SISTEMA' as tipo_documento,
        'Acceso al sistema' as nombre_cliente,
        'activo' as estado,
        NULL as estado_pago,
        m.last_login as fecha_accion,
        m.last_login as fecha_modificacion,
        m.nombre as usuario_nombre,
        m.rol as usuario_rol,
        'LOGIN' as accion,
        NULL as valor_factura,
        NULL as numero_factura
      FROM matrizadores m
      WHERE m.last_login BETWEEN :fechaInicio AND :fechaFin
      AND m.last_login IS NOT NULL
      ${whereFilters.replace('d.', 'm.')}
      
      ORDER BY fecha_accion DESC
      LIMIT :limit OFFSET :offset
    `;
    
    // Agregar limit y offset a replacements
    replacements.limit = limit;
    replacements.offset = offset;
    
    const registrosAuditoria = await sequelize.query(auditoriaQuery, {
      replacements,
      type: sequelize.QueryTypes.SELECT
    });
    
    // Consulta para contar total de registros
    const countQuery = `
      SELECT COUNT(*) as total FROM (
        SELECT d.id
        FROM documentos d
        JOIN matrizadores m ON d.id_matrizador = m.id
        WHERE d.updated_at BETWEEN :fechaInicio AND :fechaFin
        AND d.estado NOT IN ('eliminado')
        ${whereFilters}
        
        UNION ALL
        
        SELECT NULL as id
        FROM matrizadores m
        WHERE m.last_login BETWEEN :fechaInicio AND :fechaFin
        AND m.last_login IS NOT NULL
        ${whereFilters.replace('d.', 'm.')}
      ) as total_registros
    `;
    
    const countResult = await sequelize.query(countQuery, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL, tipoAccion: replacements.tipoAccion, usuario: replacements.usuario },
      type: sequelize.QueryTypes.SELECT
    });
    
    const totalRegistros = parseInt(countResult[0]?.total || 0);
    const totalPages = Math.ceil(totalRegistros / limit);
    
    // Estad칤sticas por tipo de acci칩n
    const statsQuery = `
      SELECT 
        accion,
        COUNT(*) as cantidad
      FROM (
        SELECT 
          CASE 
            WHEN d.created_at = d.updated_at THEN 'CREACI칍N'
            WHEN d.estado = 'listo_para_entrega' THEN 'PROCESAMIENTO_COMPLETADO'
            WHEN d.estado = 'entregado' THEN 'ENTREGA'
            WHEN d.estado_pago IN ('pagado_completo', 'pagado_con_retencion') THEN 'PAGO_REGISTRADO'
            WHEN d.estado = 'cancelado' THEN 'CANCELACI칍N'
            ELSE 'MODIFICACI칍N'
          END as accion
        FROM documentos d
        JOIN matrizadores m ON d.id_matrizador = m.id
        WHERE d.updated_at BETWEEN :fechaInicio AND :fechaFin
        AND d.estado NOT IN ('eliminado')
        
        UNION ALL
        
        SELECT 'LOGIN' as accion
        FROM matrizadores m
        WHERE m.last_login BETWEEN :fechaInicio AND :fechaFin
        AND m.last_login IS NOT NULL
      ) as acciones
      GROUP BY accion
      ORDER BY cantidad DESC
    `;
    
    const statsAcciones = await sequelize.query(statsQuery, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    
    // Obtener usuarios 칰nicos para filtro
    const usuariosQuery = `
      SELECT DISTINCT m.nombre, m.rol
      FROM matrizadores m
      WHERE m.activo = true
      ORDER BY m.nombre ASC
    `;
    
    const usuarios = await sequelize.query(usuariosQuery, {
      type: sequelize.QueryTypes.SELECT
    });
    
    // Preparar paginaci칩n
    const pagination = {
      currentPage: page,
      totalPages,
      totalItems: totalRegistros,
      hasNext: page < totalPages,
      hasPrev: page > 1,
      nextPage: page + 1,
      prevPage: page - 1
    };
    
    // Preparar datos para gr치fico
    const datosGrafico = {
      acciones: statsAcciones.map(item => item.accion),
      cantidades: statsAcciones.map(item => parseInt(item.cantidad))
    };
    
    res.render('admin/reportes/registros-auditoria', {
      layout: 'admin',
      title: 'Registros de Auditor칤a',
      activeReportes: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      registrosAuditoria,
      usuarios,
      statsAcciones,
      datosGrafico,
      stats: {
        totalRegistros,
        totalAcciones: statsAcciones.length,
        usuariosActivos: usuarios.length,
        periodoTexto: `Del ${fechaInicio.format('DD/MM/YYYY')} al ${fechaFin.format('DD/MM/YYYY')}`
      },
      filtros: {
        fechaInicio: fechaInicio.format('YYYY-MM-DD'),
        fechaFin: fechaFin.format('DD/MM/YYYY'),
        tipoAccion: tipoAccion || 'todos',
        usuario: usuario || 'todos'
      },
      pagination: totalPages > 1 ? pagination : null
    });
  } catch (error) {
    console.error('Error al generar reporte de auditor칤a:', error);
    return res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Error al generar el reporte de auditor칤a',
      error
    });
  }
};

/**
 * P치gina de Alertas Detallada
 * Muestra todas las situaciones que requieren atenci칩n con detalles y acciones
 */
exports.mostrarAlertas = async (req, res) => {
  try {
    // Reutilizar la l칩gica de alertas del dashboard
    const alertasCriticas = [];
    
    // Documentos atrasados m치s de 30 d칤as sin pagar
    const documentosAtrasados = await Documento.count({
      where: {
        estado_pago: 'pendiente',
        numero_factura: { [Op.not]: null },
        estado: { [Op.notIn]: ['eliminado', 'nota_credito'] },
        created_at: { [Op.lt]: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
      }
    });
    
    if (documentosAtrasados > 0) {
      alertasCriticas.push({
        tipo: 'danger',
        icono: 'fas fa-exclamation-triangle',
        titulo: `${documentosAtrasados} documentos atrasados +30 d칤as`,
        descripcion: 'Requieren gesti칩n de cobranza urgente',
        accion: '/admin/reportes/pendientes?antiguedad=30%2B',
        urgencia: 'alta',
        detalles: 'Estos documentos tienen m치s de 30 d칤as sin pago y requieren seguimiento inmediato de cobranza.'
      });
    }
    
    // Documentos listos para entrega hace m치s de 3 d칤as
    const documentosListosViejos = await Documento.count({
      where: {
        estado: 'listo_para_entrega',
        updated_at: { [Op.lt]: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000) }
      }
    });
    
    if (documentosListosViejos > 0) {
      alertasCriticas.push({
        tipo: 'warning',
        icono: 'fas fa-clock',
        titulo: `${documentosListosViejos} documentos listos sin entregar`,
        descripcion: 'M치s de 3 d칤as esperando entrega',
        accion: '/admin/documentos/listado?estado=listo_para_entrega',
        urgencia: 'media',
        detalles: 'Estos documentos est치n listos pero no han sido entregados. Contactar a los clientes para coordinar la entrega.'
      });
    }
    
    // Documentos sin matrizador asignado
    const documentosSinMatrizador = await Documento.count({
      where: {
        id_matrizador: null,
        estado: { [Op.in]: ['en_proceso', 'listo_para_entrega'] }
      }
    });
    
    if (documentosSinMatrizador > 0) {
      alertasCriticas.push({
        tipo: 'info',
        icono: 'fas fa-user-slash',
        titulo: `${documentosSinMatrizador} documentos sin asignar`,
        descripcion: 'Necesitan matrizador responsable',
        accion: '/admin/documentos/listado?idMatrizador=',
        urgencia: 'baja',
        detalles: 'Estos documentos no tienen un matrizador asignado. Asignar responsable para su procesamiento.'
      });
    }
    
    // Documentos con problemas de facturaci칩n (sin n칰mero de factura pero con valor)
    const documentosSinFactura = await Documento.count({
      where: {
        numero_factura: null,
        valor_factura: { [Op.not]: null },
        estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
      }
    });
    
    if (documentosSinFactura > 0) {
      alertasCriticas.push({
        tipo: 'warning',
        icono: 'fas fa-file-invoice',
        titulo: `${documentosSinFactura} documentos sin n칰mero de factura`,
        descripcion: 'Tienen valor pero falta n칰mero de factura',
        accion: '/admin/documentos/listado?busqueda=',
        urgencia: 'media',
        detalles: 'Estos documentos tienen valor asignado pero no tienen n칰mero de factura. Completar la informaci칩n de facturaci칩n.'
      });
    }
    
    // Determinar estado general
    let estadoGeneral = 'success';
    let mensajeEstado = 'Todo funcionando correctamente';
    
    if (documentosAtrasados > 10 || documentosListosViejos > 5) {
      estadoGeneral = 'danger';
      mensajeEstado = 'Atenci칩n requerida urgente';
    } else if (alertasCriticas.length > 0) {
      estadoGeneral = 'warning';
      mensajeEstado = 'Algunos problemas requieren atenci칩n';
    }
    
    res.render('admin/alertas', {
      layout: 'admin',
      title: 'Centro de Alertas',
      activeAlertas: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      alertasCriticas,
      estadoGeneral,
      mensajeEstado,
      stats: {
        totalAlertas: alertasCriticas.length,
        alertasAltas: alertasCriticas.filter(a => a.urgencia === 'alta').length,
        alertasMedias: alertasCriticas.filter(a => a.urgencia === 'media').length,
        alertasBajas: alertasCriticas.filter(a => a.urgencia === 'baja').length
      }
    });
  } catch (error) {
    console.error('Error al cargar alertas:', error);
    res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Ha ocurrido un error al cargar las alertas',
      error
    });
  }
};

/**
 * Reporte de Cobros por Matrizador - MEJORADO PARA COMISIONES
 * An치lisis detallado de cobros realizados por cada matrizador con UX profesional
 */
exports.reporteCobrosMatrizador = async (req, res) => {
  try {
    // Procesar par치metros de filtrado
    const rango = req.query.rango || 'mes';
    const idMatrizador = req.query.idMatrizador; // Filtro por matrizador espec칤fico
    let fechaInicio, fechaFin, periodoTexto;
    
    // Establecer fechas seg칰n el rango seleccionado
    const hoy = moment().startOf('day');
    
    switch (rango) {
      case 'desde_inicio':
        // NUEVO: Mostrar todos los datos hist칩ricos
        fechaInicio = moment('2020-01-01').startOf('day'); // Fecha muy antigua para incluir todo
        fechaFin = moment().endOf('day');
        periodoTexto = 'Desde el Inicio (Todos los datos hist칩ricos)';
        break;
      case 'hoy':
        fechaInicio = hoy.clone();
        fechaFin = moment().endOf('day');
        periodoTexto = 'Hoy ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'ayer':
        fechaInicio = hoy.clone().subtract(1, 'days');
        fechaFin = hoy.clone().subtract(1, 'days').endOf('day');
        periodoTexto = 'Ayer ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'semana':
        fechaInicio = hoy.clone().startOf('week');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Esta semana (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'mes':
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'ultimo_mes':
        fechaInicio = hoy.clone().subtract(30, 'days');
        fechaFin = moment().endOf('day');
        periodoTexto = '칔ltimos 30 d칤as';
        break;
      case 'personalizado':
        fechaInicio = req.query.fechaInicio ? moment(req.query.fechaInicio).startOf('day') : hoy.clone().startOf('month');
        fechaFin = req.query.fechaFin ? moment(req.query.fechaFin).endOf('day') : moment().endOf('day');
        periodoTexto = 'Del ' + fechaInicio.format('DD/MM/YYYY') + ' al ' + fechaFin.format('DD/MM/YYYY');
        break;
      default:
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
    }
    
    // Formatear fechas para consultas SQL
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    
    // Consulta principal: cobros por matrizador usando fecha_pago
    let whereMatrizador = '';
    if (idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '') {
      whereMatrizador = `AND m.id = ${parseInt(idMatrizador)}`;
    }
    
    const cobrosMatrizadorQuery = `
      SELECT 
        m.id,
        m.nombre,
        m.email,
        COUNT(d.id) as documentos_cobrados,
        COALESCE(SUM(d.valor_pagado), 0) as total_cobrado,
        COALESCE(AVG(d.valor_factura), 0) as promedio_por_documento,
        MIN(d.fecha_ultimo_pago) as primer_cobro,
        MAX(d.fecha_ultimo_pago) as ultimo_cobro
      FROM matrizadores m
      LEFT JOIN documentos d ON m.id = d.id_matrizador
        AND d.estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial')
        AND d.fecha_ultimo_pago BETWEEN :fechaInicio AND :fechaFin
        AND d.estado NOT IN ('eliminado', 'nota_credito')
      WHERE m.rol IN ('matrizador', 'caja_archivo')
      AND m.activo = true
      ${whereMatrizador}
      GROUP BY m.id, m.nombre, m.email
      ORDER BY total_cobrado DESC
    `;
    
    const cobrosMatrizador = await sequelize.query(cobrosMatrizadorQuery, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    
    // Estad칤sticas generales del per칤odo
    const totalCobradoPeriodo = cobrosMatrizador.reduce((sum, item) => sum + parseFloat(item.total_cobrado || 0), 0);
    const totalDocumentosCobrados = cobrosMatrizador.reduce((sum, item) => sum + parseInt(item.documentos_cobrados || 0), 0);
    const promedioGeneral = totalDocumentosCobrados > 0 ? totalCobradoPeriodo / totalDocumentosCobrados : 0;
    
    // Obtener detalles de cobros recientes (칰ltimos 20)
    let whereDetalles = `
      WHERE d.estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial')
      AND d.fecha_ultimo_pago BETWEEN :fechaInicio AND :fechaFin
      AND d.estado NOT IN ('eliminado', 'nota_credito')
    `;
    if (idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '') {
      whereDetalles += ` AND d.id_matrizador = ${parseInt(idMatrizador)}`;
    }
    
    const cobrosRecientesQuery = `
      SELECT 
        d.id,
        d.codigo_barras,
        d.tipo_documento,
        d.nombre_cliente,
        d.valor_factura,
        d.valor_pagado,
        d.fecha_ultimo_pago,
        d.metodo_pago,
        d.estado_pago,
        m.nombre as matrizador_nombre
      FROM documentos d
      JOIN matrizadores m ON d.id_matrizador = m.id
      ${whereDetalles}
      ORDER BY d.fecha_ultimo_pago DESC
      LIMIT 20
    `;
    
    const cobrosRecientes = await sequelize.query(cobrosRecientesQuery, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    
    // Obtener todos los matrizadores para el filtro
    const matrizadores = await Matrizador.findAll({
      attributes: ['id', 'nombre'],
      where: { 
        activo: true, 
        rol: {
          [Op.in]: ['matrizador', 'caja_archivo']
        }
      },
      order: [['nombre', 'ASC']],
      raw: true
    });
    
    // NUEVO: Obtener informaci칩n del matrizador seleccionado
    let matrizadorSeleccionado = null;
    if (idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '') {
      matrizadorSeleccionado = await Matrizador.findByPk(parseInt(idMatrizador), {
        attributes: ['id', 'nombre', 'email']
      });
    }
    
    // Preparar datos para gr치fico
    const datosGrafico = {
      nombres: cobrosMatrizador.map(item => item.nombre),
      montos: cobrosMatrizador.map(item => parseFloat(item.total_cobrado || 0)),
      documentos: cobrosMatrizador.map(item => parseInt(item.documentos_cobrados || 0))
    };
    
    // NUEVO: Preparar datos mejorados para la vista
    const datosVista = {
      layout: 'admin',
      title: 'Reporte de Comisiones por Matrizador',
      activeReportes: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      
      // Datos principales
      cobrosMatrizador,
      cobrosRecientes,
      matrizadores,
      datosGrafico,
      
      // Informaci칩n del contexto
      periodoTexto,
      matrizadorSeleccionado,
      idMatrizadorSeleccionado: idMatrizador || 'todos',
      
      // Estad칤sticas mejoradas
      stats: {
        totalCobradoPeriodo: formatearValorMonetario(totalCobradoPeriodo),
        totalDocumentosCobrados,
        promedioGeneral: formatearValorMonetario(promedioGeneral),
        matrizadoresActivos: cobrosMatrizador.filter(m => parseInt(m.documentos_cobrados) > 0).length
      },
      
      // Filtros con informaci칩n adicional
      filtros: {
        rango,
        idMatrizador,
        fechaInicio: fechaInicio.format('YYYY-MM-DD'),
        fechaFin: fechaFin.format('YYYY-MM-DD'),
        // Flags para la vista
        esHoy: rango === 'hoy',
        esAyer: rango === 'ayer',
        esSemana: rango === 'semana',
        esMes: rango === 'mes',
        esUltimoMes: rango === 'ultimo_mes',
        esPersonalizado: rango === 'personalizado'
      }
    };
    
    // Renderizar la vista con datos mejorados
    res.render('admin/reportes/cobros-matrizador', datosVista);
    
  } catch (error) {
    console.error('Error al generar reporte de cobros por matrizador:', error);
    return res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Error al generar el reporte de cobros por matrizador',
      error
    });
  }
};

/**
 * Reporte de Productividad de Matrizadores - LIMPIO SIN NOTIFICACIONES
 * An치lisis completo de rendimiento con tiempos, calidad y volumen real
 */
exports.reporteProductividadMatrizadores = async (req, res) => {
  try {
    console.log('=== INICIO: Reporte Productividad Limpio ===');
    
    // Procesar par치metros de filtrado
    const rango = req.query.rango || 'mes';
    const idMatrizador = req.query.idMatrizador;
    let fechaInicio, fechaFin, periodoTexto;
    
    // Establecer fechas seg칰n el rango seleccionado
    const hoy = moment().startOf('day');
    
    switch (rango) {
      case 'desde_inicio':
        // NUEVO: Mostrar todos los datos hist칩ricos
        fechaInicio = moment('2020-01-01').startOf('day'); // Fecha muy antigua para incluir todo
        fechaFin = moment().endOf('day');
        periodoTexto = 'Desde el Inicio (Todos los datos hist칩ricos)';
        break;
      case 'hoy':
        fechaInicio = hoy.clone();
        fechaFin = moment().endOf('day');
        periodoTexto = 'Hoy ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'ayer':
        fechaInicio = hoy.clone().subtract(1, 'days');
        fechaFin = hoy.clone().subtract(1, 'days').endOf('day');
        periodoTexto = 'Ayer ' + fechaInicio.format('DD/MM/YYYY');
        break;
      case 'semana':
        fechaInicio = hoy.clone().startOf('week');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Esta semana (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'mes':
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
        break;
      case 'ultimo_mes':
        fechaInicio = hoy.clone().subtract(30, 'days');
        fechaFin = moment().endOf('day');
        periodoTexto = '칔ltimos 30 d칤as';
        break;
      case 'personalizado':
        fechaInicio = req.query.fechaInicio ? moment(req.query.fechaInicio).startOf('day') : hoy.clone().startOf('month');
        fechaFin = req.query.fechaFin ? moment(req.query.fechaFin).endOf('day') : moment().endOf('day');
        periodoTexto = 'Del ' + fechaInicio.format('DD/MM/YYYY') + ' al ' + fechaFin.format('DD/MM/YYYY');
        break;
      default:
        fechaInicio = hoy.clone().startOf('month');
        fechaFin = moment().endOf('day');
        periodoTexto = 'Este mes (desde ' + fechaInicio.format('DD/MM/YYYY') + ')';
    }
    
    // Formatear fechas para consultas SQL
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    
    // Cl치usula WHERE base para documentos
    const whereClause = {
      created_at: {
        [Op.between]: [fechaInicio.toDate(), fechaFin.toDate()]
      },
      estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
    };
    
    // CORRECCI칍N: Filtro de matrizador funcional
    if (idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '') {
      whereClause.id_matrizador = parseInt(idMatrizador, 10);
    }
    
    // Estad칤sticas b치sicas globales
    const totalDocumentos = await Documento.count({ where: whereClause }) || 0;
    const documentosCompletados = await Documento.count({
      where: { ...whereClause, estado: 'listo_para_entrega' }
    }) || 0;
    const documentosEntregados = await Documento.count({
      where: { ...whereClause, estado: 'entregado' }
    }) || 0;
    
    // NUEVA M칄TRICA: Documentos atrasados (m치s de 3 d칤as en proceso)
    const documentosAtrasados = await Documento.count({
      where: {
        estado: 'en_proceso',
        created_at: { [Op.lt]: moment().subtract(3, 'days').toDate() },
        ...(idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '' && {
          id_matrizador: parseInt(idMatrizador, 10)
        })
      }
    }) || 0;
    
    // Obtener todos los matrizadores activos
    const matrizadores = await Matrizador.findAll({
      where: {
        rol: { [Op.in]: ['matrizador', 'caja_archivo'] },
        activo: true
      },
      attributes: ['id', 'nombre', 'email'],
      order: [['nombre', 'ASC']],
      raw: true
    });
    
    // CORRECCI칍N CR칈TICA: Filtrar matrizadores seg칰n selecci칩n
    let matrizadoresFiltrados = matrizadores;
    if (idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '') {
      // Si se selecciona un matrizador espec칤fico, solo procesar ese matrizador
      matrizadoresFiltrados = matrizadores.filter(m => m.id == parseInt(idMatrizador, 10));
    }
    
    // MEJORA: C치lculos de productividad por matrizador (SIN NOTIFICACIONES)
    const productividadMatrizadores = await Promise.all(
      matrizadoresFiltrados.map(async (matrizador) => {
        // Filtro espec칤fico por matrizador
        const whereMatrizador = {
          ...whereClause,
          id_matrizador: matrizador.id
        };
        
        // M칠tricas b치sicas de productividad
        const documentos_registrados = await Documento.count({ where: whereMatrizador }) || 0;
        const documentos_completados = await Documento.count({ 
          where: { ...whereMatrizador, estado: 'listo_para_entrega' } 
        }) || 0;
        const documentos_entregados = await Documento.count({ 
          where: { ...whereMatrizador, estado: 'entregado' } 
        }) || 0;
        const facturacion_total = await Documento.sum('valor_factura', { 
          where: whereMatrizador 
        }) || 0;
        
        // NUEVA M칄TRICA: Documentos atrasados por matrizador
        const documentos_atrasados = await Documento.count({
          where: {
            ...whereMatrizador,
            estado: 'en_proceso',
            created_at: { [Op.lt]: moment().subtract(3, 'days').toDate() }
          }
        }) || 0;
        
        // NUEVA M칄TRICA: Tiempo promedio de procesamiento
        const tiempoPromedioQuery = await sequelize.query(`
          SELECT AVG(EXTRACT(DAY FROM (
            CASE 
              WHEN d.estado = 'listo_para_entrega' OR d.estado = 'entregado' 
              THEN COALESCE(d.updated_at, NOW())
              ELSE NOW()
            END - d.created_at
          ))) as tiempo_promedio_dias
          FROM documentos d
          WHERE d.id_matrizador = :idMatrizador
          AND d.created_at BETWEEN :fechaInicio AND :fechaFin
          AND d.estado NOT IN ('eliminado', 'nota_credito')
        `, {
          replacements: { 
            idMatrizador: matrizador.id, 
            fechaInicio: fechaInicioSQL, 
            fechaFin: fechaFinSQL 
          },
          type: sequelize.QueryTypes.SELECT
        });
        
        const tiempo_promedio_dias = tiempoPromedioQuery[0]?.tiempo_promedio_dias || 0;
        
        // NUEVA M칄TRICA: Documentos por d칤a (promedio diario)
        const diasPeriodo = fechaFin.diff(fechaInicio, 'days') + 1;
        const documentos_por_dia = diasPeriodo > 0 ? (documentos_registrados / diasPeriodo).toFixed(1) : 0;
        
        // NUEVA M칄TRICA: Eficiencia temporal (% completados a tiempo)
        const documentos_a_tiempo = documentos_completados + documentos_entregados - documentos_atrasados;
        const eficiencia_temporal = documentos_registrados > 0 ? 
          Math.round((documentos_a_tiempo / documentos_registrados) * 100) : 0;
        
        // NUEVA M칄TRICA: Tasa de calidad (sin devoluciones - estimaci칩n)
        const tasa_calidad = Math.max(85, eficiencia_temporal); // Estimaci칩n optimista
        
        return {
          id: matrizador.id,
          nombre: matrizador.nombre,
          email: matrizador.email,
          // M칠tricas de productividad real
          documentos_registrados,
          documentos_completados,
          documentos_entregados,
          facturacion_total: parseFloat(facturacion_total),
          eficiencia_procesamiento: documentos_registrados > 0 ? 
            Math.round((documentos_completados / documentos_registrados) * 100) : 0,
          facturacion_total_formato: formatearValorMonetario(facturacion_total),
          // Nuevas m칠tricas de productividad
          documentos_atrasados,
          tiempo_promedio_dias: parseFloat(tiempo_promedio_dias).toFixed(1),
          documentos_por_dia,
          eficiencia_temporal,
          tasa_calidad,
          // M칠tricas adicionales para an치lisis
          documentos_en_proceso: documentos_registrados - documentos_completados - documentos_entregados,
          porcentaje_entregados: documentos_registrados > 0 ? 
            Math.round((documentos_entregados / documentos_registrados) * 100) : 0
        };
      })
    );
    
    // MEJORA: Estad칤sticas globales limpias (SIN NOTIFICACIONES) - CORREGIDAS PARA FILTROS
    const totalFacturacion = productividadMatrizadores.reduce((sum, item) => sum + item.facturacion_total, 0);
    const tiempoPromedioGeneral = productividadMatrizadores.length > 0 ? 
      (productividadMatrizadores.reduce((sum, item) => sum + parseFloat(item.tiempo_promedio_dias), 0) / productividadMatrizadores.length).toFixed(1) : 0;
    
    // CORRECCI칍N: Calcular estad칤sticas globales basadas en los filtros aplicados
    const totalDocumentosFiltrados = productividadMatrizadores.reduce((sum, item) => sum + item.documentos_registrados, 0);
    const totalCompletadosFiltrados = productividadMatrizadores.reduce((sum, item) => sum + item.documentos_completados, 0);
    const totalEntregadosFiltrados = productividadMatrizadores.reduce((sum, item) => sum + item.documentos_entregados, 0);
    const totalAtrasadosFiltrados = productividadMatrizadores.reduce((sum, item) => sum + item.documentos_atrasados, 0);
    
    // CORRECCI칍N: Calcular documentos por d칤a promedio basado en filtros
    const diasPeriodo = fechaFin.diff(fechaInicio, 'days') + 1;
    const documentosPorDiaPromedioFiltrado = diasPeriodo > 0 ? (totalDocumentosFiltrados / diasPeriodo).toFixed(1) : 0;
    
    // Datos para gr치ficos (mantener compatibilidad)
    const datosGrafico = {
      nombres: productividadMatrizadores.map(item => item.nombre),
      registrados: productividadMatrizadores.map(item => item.documentos_registrados),
      completados: productividadMatrizadores.map(item => item.documentos_completados),
      entregados: productividadMatrizadores.map(item => item.documentos_entregados),
      facturacion: productividadMatrizadores.map(item => item.facturacion_total),
      // Nuevos datos para gr치ficos
      tiempos: productividadMatrizadores.map(item => parseFloat(item.tiempo_promedio_dias))
    };
    
    console.log('=== DEBUG: Datos limpios preparados, renderizando vista ===');
    
    // Renderizar la vista con datos limpios
    res.render('admin/reportes/productividad-matrizadores', {
      layout: 'admin',
      title: 'Productividad de Matrizadores',
      activeReportes: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      productividadMatrizadores,
      matrizadores,
      idMatrizadorSeleccionado: idMatrizador || 'todos', // CORRECCI칍N: Mantener selecci칩n
      stats: {
        // Stats limpios sin notificaciones - CORREGIDOS PARA FILTROS
        totalDocumentos: totalDocumentosFiltrados, // CORREGIDO: usar valor filtrado
        totalCompletados: totalCompletadosFiltrados, // CORREGIDO: usar valor filtrado
        totalEntregados: totalEntregadosFiltrados, // CORREGIDO: usar valor filtrado
        totalFacturacion: formatearValorMonetario(totalFacturacion),
        eficienciaGeneral: totalDocumentosFiltrados > 0 ? Math.round((totalCompletadosFiltrados / totalDocumentosFiltrados) * 100) : 0, // CORREGIDO
        matrizadoresActivos: productividadMatrizadores.filter(m => m.documentos_registrados > 0).length,
        promedioDocumentos: productividadMatrizadores.length > 0 ? Math.round(totalDocumentosFiltrados / productividadMatrizadores.length) : 0, // CORREGIDO
        // Nuevas estad칤sticas globales limpias - CORREGIDAS
        documentosAtrasados: totalAtrasadosFiltrados, // CORREGIDO: usar valor filtrado
        tiempoPromedioGeneral,
        documentosPorDiaPromedio: documentosPorDiaPromedioFiltrado, // CORREGIDO: usar valor filtrado
        tasaCalidadPromedio: productividadMatrizadores.length > 0 ?
          Math.round(productividadMatrizadores.reduce((sum, item) => sum + item.tasa_calidad, 0) / productividadMatrizadores.length) : 0
      },
      datosGrafico,
      periodoTexto,
      filtros: {
        rango,
        idMatrizador: idMatrizador || 'todos', // CORRECCI칍N: Mantener en filtros
        fechaInicio: fechaInicio.format('YYYY-MM-DD'),
        fechaFin: fechaFin.format('YYYY-MM-DD')
      },
      // Informaci칩n adicional para la vista
      esFiltradoPorMatrizador: idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '',
      matrizadorFiltradoNombre: idMatrizador && idMatrizador !== 'todos' && idMatrizador !== '' ?
        matrizadores.find(m => m.id == idMatrizador)?.nombre : null
    });
    
    console.log('=== 칄XITO: Vista de productividad limpia renderizada ===');
  } catch (error) {
    console.error('=== ERROR: Reporte de productividad limpio ===', error);
    return res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Error al generar el reporte de productividad de matrizadores',
      error
    });
  }
};

// ============== FUNCIONES AUXILIARES ==============

/**
 * TRANSFERIDO DESDE CAJA: Reporte de documentos sin pago
 * Solo para administradores - informaci칩n sensible sobre cobranza
 */
exports.reporteDocumentosSinPago = async (req, res) => {
  try {
    // Obtener par치metros de filtrado
    const { antiguedad, matrizador, ordenar, page = 1 } = req.query;
    const limit = 50;
    const offset = (page - 1) * limit;
    
    // CORREGIDO: Usar valores correctos del ENUM para estado_pago
    const whereConditions = {
      [Op.or]: [
        { estado_pago: 'pendiente' },
        { estado_pago: 'pago_parcial' } // NUEVO: Incluir pagos parciales
      ],
      numero_factura: { [Op.not]: null },
      estado: { [Op.notIn]: ['eliminado', 'nota_credito', 'cancelado'] }
    };
    
    if (matrizador && matrizador !== 'todos') {
      whereConditions.id_matrizador = parseInt(matrizador);
    }
    
    // Filtro por antig칲edad
    if (antiguedad) {
      const diasAtras = parseInt(antiguedad);
      const fechaLimite = moment().subtract(diasAtras, 'days').format('YYYY-MM-DD');
      whereConditions.created_at = { [Op.lte]: fechaLimite };
    }
    
    // Construir ORDER BY seg칰n el filtro
    let order = [['created_at', 'ASC']]; // Por defecto m치s antiguos
    if (ordenar === 'monto') {
      order = [['valor_pendiente', 'DESC']]; // CORREGIDO: Ordenar por valor pendiente
    } else if (ordenar === 'fecha') {
      order = [['created_at', 'DESC']];
    }
    
    // Obtener documentos sin pago completo
    const { count, rows: documentosSinPago } = await Documento.findAndCountAll({
      where: whereConditions,
      include: [{
        model: Matrizador,
        as: 'matrizador',
        attributes: ['id', 'nombre']
      }],
      order,
      limit,
      offset
    });
    
    // CORREGIDO: Calcular estad칤sticas usando valores correctos del ENUM
    const statsQuery = `
      SELECT 
        COUNT(CASE WHEN EXTRACT(DAY FROM NOW() - created_at) BETWEEN 1 AND 7 THEN 1 END) as rango1_7,
        COUNT(CASE WHEN EXTRACT(DAY FROM NOW() - created_at) BETWEEN 8 AND 15 THEN 1 END) as rango8_15,
        COUNT(CASE WHEN EXTRACT(DAY FROM NOW() - created_at) BETWEEN 16 AND 60 THEN 1 END) as rango16_60,
        COUNT(CASE WHEN EXTRACT(DAY FROM NOW() - created_at) > 60 THEN 1 END) as rango60,
        SUM(CASE WHEN EXTRACT(DAY FROM NOW() - created_at) BETWEEN 1 AND 7 THEN valor_pendiente ELSE 0 END) as monto1_7,
        SUM(CASE WHEN EXTRACT(DAY FROM NOW() - created_at) BETWEEN 8 AND 15 THEN valor_pendiente ELSE 0 END) as monto8_15,
        SUM(CASE WHEN EXTRACT(DAY FROM NOW() - created_at) BETWEEN 16 AND 60 THEN valor_pendiente ELSE 0 END) as monto16_60,
        SUM(CASE WHEN EXTRACT(DAY FROM NOW() - created_at) > 60 THEN valor_pendiente ELSE 0 END) as monto60,
        COUNT(*) as totalSinPago,
        SUM(valor_pendiente) as montoTotalPendiente
      FROM documentos
      WHERE (estado_pago = 'pendiente' OR estado_pago = 'pago_parcial')
      AND numero_factura IS NOT NULL
      AND estado NOT IN ('eliminado', 'nota_credito', 'cancelado')
      ${matrizador && matrizador !== 'todos' ? `AND id_matrizador = ${parseInt(matrizador)}` : ''}
    `;
    
    const stats = await sequelize.query(statsQuery, {
      type: sequelize.QueryTypes.SELECT
    });
    
    const statsResult = stats[0];
    
    // Obtener lista de matrizadores para filtros
    const matrizadores = await Matrizador.findAll({
      where: {
        rol: { [Op.in]: ['matrizador', 'caja_archivo'] },
        activo: true
      },
      attributes: ['id', 'nombre'],
      order: [['nombre', 'ASC']]
    });
    
    // Agregar d칤as de antig칲edad y datos calculados a cada documento
    const documentosConDatos = documentosSinPago.map(doc => {
      const diasAntiguedad = moment().diff(moment(doc.created_at), 'days');
      return {
        ...doc.toJSON(),
        diasAntiguedad,
        matrizador: doc.matrizador?.nombre || 'Sin asignar',
        // NUEVO: Mostrar informaci칩n de pago parcial
        esPagoParcial: doc.estadoPago === 'pago_parcial',
        valorPagadoFormato: formatearValorMonetario(doc.valorPagado || 0),
        valorPendienteFormato: formatearValorMonetario(doc.valorPendiente || doc.valorFactura),
        valorFacturaFormato: formatearValorMonetario(doc.valorFactura || 0)
      };
    });
    
    // Calcular paginaci칩n
    const totalPages = Math.ceil(count / limit);
    
    // Renderizar la vista con los datos
    res.render('admin/reportes/documentos-sin-pago', {
      layout: 'admin',
      title: 'Documentos Sin Pago Completo',
      activeReportes: true,
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      documentosSinPago: documentosConDatos,
      stats: {
        rango1_7: parseInt(statsResult.rango1_7) || 0,
        rango8_15: parseInt(statsResult.rango8_15) || 0,
        rango16_60: parseInt(statsResult.rango16_60) || 0,
        rango60: parseInt(statsResult.rango60) || 0,
        monto1_7: parseFloat(statsResult.monto1_7) || 0,
        monto8_15: parseFloat(statsResult.monto8_15) || 0,
        monto16_60: parseFloat(statsResult.monto16_60) || 0,
        monto60: parseFloat(statsResult.monto60) || 0,
        totalSinPago: parseInt(statsResult.totalsinpago) || 0,
        montoTotalPendiente: parseFloat(statsResult.montototalpendiente) || 0
      },
      matrizadores,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1,
        nextPage: parseInt(page) + 1,
        prevPage: parseInt(page) - 1
      },
      filtros: {
        antiguedad,
        matrizador,
        ordenar
      }
    });
  } catch (error) {
    console.error('Error al generar reporte de documentos sin pago:', error);
    return res.status(500).render('error', {
      layout: 'admin',
      title: 'Error',
      message: 'Error al generar el reporte de documentos sin pago',
      error
    });
  }
};

/**
 * COPIADO DE RECEPCI칍N: Historial completo de notificaciones para administradores
 * Muestra el historial completo de notificaciones con filtros avanzados
 */
exports.historialNotificaciones = async (req, res) => {
  try {
    const { 
      fechaDesde, 
      fechaHasta, 
      tipo, 
      canal, 
      matrizador, 
      codigoDocumento,
      cliente,
      numeroFactura,
      busqueda
    } = req.query;
    
    let whereClause = {};
    let documentoWhere = {};
    
    // Filtro por fechas
    if (fechaDesde || fechaHasta) {
      whereClause.created_at = {};
      if (fechaDesde) {
        whereClause.created_at[Op.gte] = new Date(fechaDesde + 'T00:00:00');
      }
      if (fechaHasta) {
        whereClause.created_at[Op.lte] = new Date(fechaHasta + 'T23:59:59');
      }
    }
    
    // Filtros de tipo y canal
    if (tipo) whereClause.tipo = tipo;
    if (canal && canal !== '') {
      // Buscar en metadatos.canal
      whereClause['metadatos.canal'] = canal;
    }
    
    // ============== B칔SQUEDA POR TEXTO ==============
    if (busqueda && busqueda.trim() !== '') {
      const textoBusqueda = busqueda.trim();
      documentoWhere[Op.or] = [
        // Buscar por c칩digo de barras
        { codigoBarras: { [Op.iLike]: `%${textoBusqueda}%` } },
        // Buscar por nombre del cliente
        { nombreCliente: { [Op.iLike]: `%${textoBusqueda}%` } },
        // Buscar por n칰mero de factura
        { numeroFactura: { [Op.iLike]: `%${textoBusqueda}%` } },
        // Buscar por identificaci칩n del cliente
        { identificacionCliente: { [Op.iLike]: `%${textoBusqueda}%` } }
      ];
    }
    
    // Filtros espec칤ficos de documento
    if (codigoDocumento) {
      documentoWhere.codigoBarras = {
        [Op.iLike]: `%${codigoDocumento}%`
      };
    }
    
    if (cliente) {
      documentoWhere.nombreCliente = {
        [Op.iLike]: `%${cliente}%`
      };
    }
    
    if (numeroFactura) {
      documentoWhere.numeroFactura = {
        [Op.iLike]: `%${numeroFactura}%`
      };
    }
    
    // Filtro por matrizador
    if (matrizador) {
      documentoWhere.idMatrizador = matrizador;
    }
    
    const notificaciones = await EventoDocumento.findAll({
      where: {
        tipo: {
          [Op.in]: ['documento_listo', 'documento_entregado']
        },
        ...whereClause
      },
      include: [
        {
          model: Documento,
          as: 'documento',
          where: documentoWhere,
          attributes: [
            'id',
            'codigoBarras', 
            'tipoDocumento', 
            'nombreCliente',
            'emailCliente',
            'telefonoCliente',
            'numeroFactura',
            'estado',
            'identificacionCliente',
            'notas'
          ],
          include: [
            {
              model: Matrizador,
              as: 'matrizador',
              attributes: ['nombre'],
              required: false
            }
          ],
          required: true
        }
      ],
      order: [['created_at', 'DESC']],
      limit: 100 // M치s resultados para admin
    });
    
    // Obtener lista de matrizadores para filtro
    const matrizadores = await Matrizador.findAll({
      attributes: ['id', 'nombre'],
      where: { activo: true },
      order: [['nombre', 'ASC']]
    });
    
    // ============== CALCULAR ESTAD칈STICAS ==============
    const stats = {
      total: notificaciones.length,
      enviadas: notificaciones.filter(n => n.metadatos?.estado === 'enviado').length || 0,
      fallidas: notificaciones.filter(n => n.metadatos?.estado === 'error').length || 0,
      pendientes: notificaciones.filter(n => n.metadatos?.estado === 'pendiente').length || 0
    };
    
    res.render('admin/notificaciones/historial', {
      layout: 'admin',
      title: 'Control de Notificaciones',
      activeNotificaciones: true,
      notificaciones,
      matrizadores,
      stats,
      filtros: { 
        fechaDesde, 
        fechaHasta, 
        tipo, 
        canal, 
        matrizador, 
        codigoDocumento,
        cliente,
        numeroFactura,
        busqueda
      },
      userRole: req.matrizador?.rol,
      userName: req.matrizador?.nombre,
      usuario: {
        id: req.matrizador?.id,
        rol: req.matrizador?.rol,
        nombre: req.matrizador?.nombre
      }
    });
    
  } catch (error) {
    console.error('Error en historial notificaciones admin:', error);
    res.status(500).render('error', { 
      layout: 'admin',
      title: 'Error',
      message: 'Error al cargar historial de notificaciones' 
    });
  }
};

/**
 * COPIADO DE RECEPCI칍N: Obtiene los detalles de una notificaci칩n espec칤fica (API) para admin
 */
exports.obtenerDetalleNotificacion = async (req, res) => {
  try {
    const { id } = req.params;
    
    if (!id) {
      return res.status(400).json({
        exito: false,
        mensaje: 'ID de notificaci칩n no proporcionado'
      });
    }
    
    // Buscar el evento de notificaci칩n
    const evento = await EventoDocumento.findOne({
      where: {
        id: id,
        tipo: {
          [Op.in]: ['documento_listo', 'documento_entregado']
        }
      },
      include: [{
        model: Documento,
        as: 'documento',
        attributes: ['codigoBarras', 'tipoDocumento', 'nombreCliente', 'emailCliente', 'telefonoCliente', 'notas', 'numeroFactura', 'estado'],
        include: [{
          model: Matrizador,
          as: 'matrizador',
          attributes: ['nombre'],
          required: false
        }]
      }]
    });
    
    if (!evento) {
      return res.status(404).json({
        exito: false,
        mensaje: 'Notificaci칩n no encontrada'
      });
    }
    
    // Preparar datos para la respuesta
    const datos = {
      tipo: evento.tipo,
      fecha: evento.created_at,
      usuario: evento.usuario || 'Sistema',
      metadatos: evento.metadatos || {},
      detalles: evento.descripcion || '',
      documento: {
        codigo: evento.documento?.codigoBarras || 'N/A',
        tipo: evento.documento?.tipoDocumento || 'N/A',
        cliente: evento.documento?.nombreCliente || 'N/A',
        estado: evento.documento?.estado || 'N/A',
        matrizador: evento.documento?.matrizador?.nombre || 'Sin asignar',
        numeroFactura: evento.documento?.numeroFactura || null
      },
      canales: {
        email: evento.documento?.emailCliente || null,
        telefono: evento.documento?.telefonoCliente || null
      },
      // MEJORA: Construir mensaje completo basado en el tipo de evento
      mensajeEnviado: construirMensajeCompleto(evento, evento.documento)
    };
    
    res.json({
      exito: true,
      datos
    });
    
  } catch (error) {
    console.error('Error al obtener detalle de notificaci칩n:', error);
    res.status(500).json({
      exito: false,
      mensaje: 'Error interno del servidor'
    });
  }
};

/**
 * FUNCI칍N AUXILIAR: Construir mensaje completo de notificaci칩n
 * Recrea el mensaje que se envi칩 al cliente basado en el tipo de evento
 */
function construirMensajeCompleto(evento, documento) {
  if (!documento) return 'Documento no disponible';
  
  const tipoDoc = documento.tipoDocumento || 'documento';
  const codigo = documento.codigoBarras || 'N/A';
  const cliente = documento.nombreCliente || 'Cliente';
  
  if (evento.tipo === 'documento_listo') {
    return `游댒 NOTIFICACI칍N NOTAR칈A REINOSO

Estimado/a ${cliente},

Su ${tipoDoc.toLowerCase()} est치 LISTO para retiro.

游늯 C칩digo: ${codigo}
游늸 Direcci칩n: Av. Amazonas N24-155 y Col칩n
游 Horario: Lunes a Viernes 8:30-17:30
游 Tel칠fono: (02) 2553-456

Para retirar su documento necesita:
九 C칠dula de identidad original
九 C칩digo de verificaci칩n (se proporcionar치 al momento)

춰Gracias por confiar en nosotros!

Notar칤a Reinoso
www.notariareinoso.com`;
  } else if (evento.tipo === 'documento_entregado') {
    return `九 CONFIRMACI칍N DE ENTREGA - NOTAR칈A REINOSO

Estimado/a ${cliente},

Confirmamos la ENTREGA EXITOSA de su documento.

游늯 C칩digo: ${codigo}
游늰 Fecha de entrega: ${new Date().toLocaleDateString('es-EC')}
游 Hora: ${new Date().toLocaleTimeString('es-EC')}

Su tr치mite ha sido completado satisfactoriamente.

춰Gracias por confiar en Notar칤a Reinoso!

Para consultas: (02) 2553-456
www.notariareinoso.com`;
  }
  
  return evento.metadatos?.mensaje || 'Mensaje no disponible';
}
