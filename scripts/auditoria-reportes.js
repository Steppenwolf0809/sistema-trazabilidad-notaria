/**
 * AUDITOR√çA COMPLETA DEL SISTEMA DE REPORTES
 * 
 * Este script detecta inconsistencias matem√°ticas cr√≠ticas en todos los reportes
 * del sistema, especialmente el problema donde "cobrado > facturado".
 * 
 * PROBLEMA DETECTADO: Reporte financiero con inconsistencias en c√°lculos
 * CAUSA PROBABLE: Diferentes m√©todos de c√°lculo en Admin vs Caja + rol archivo
 * 
 * AUTOR: Sistema de Auditor√≠a Automatizada
 * FECHA: 2025-01-29
 */

const { Documento, Matrizador, Pago, EventoDocumento } = require('../models');
const { sequelize } = require('../config/database');
const { Op } = require('sequelize');
const moment = require('moment');

class AuditoriaReportes {
  constructor() {
    this.errores = [];
    this.advertencias = [];
    this.inconsistencias = [];
    this.resultados = {
      integridad: {},
      financiero: {},
      admin: {},
      caja: {},
      roles: {}
    };
  }

  async ejecutarAuditoria() {
    console.log('üîç INICIANDO AUDITOR√çA COMPLETA DE REPORTES');
    console.log('================================================');
    console.log(`Fecha: ${moment().format('DD/MM/YYYY HH:mm:ss')}`);
    console.log(`Usuario: Auditor√≠a Automatizada`);
    console.log('');
    
    try {
      // 1. Auditar integridad b√°sica de datos
      await this.auditarIntegridadDatos();
      
      // 2. Auditar reportes financieros (CR√çTICO)
      await this.auditarReportesFinancieros();
      
      // 3. Auditar m√©todos de c√°lculo
      await this.auditarMetodosCalculo();
      
      // 4. Auditar reportes de admin vs caja
      await this.auditarComparacionReportes();
      
      // 5. Auditar filtros por rol (problema archivo)
      await this.auditarFiltrosPorRol();
      
      // 6. Auditar queries SQL espec√≠ficas
      await this.auditarQueriesSQL();
      
      // 7. Generar reporte final
      this.generarReporteFinal();
      
    } catch (error) {
      console.error('‚ùå Error durante auditor√≠a:', error);
      throw error;
    }
  }

  async auditarIntegridadDatos() {
    console.log('\nüìä 1. AUDITANDO INTEGRIDAD DE DATOS');
    console.log('-------------------------------------');
    
    try {
      // Verificar documentos sin matrizador
      const docsSinMatrizador = await Documento.count({
        where: { idMatrizador: null }
      });
      
      if (docsSinMatrizador > 0) {
        this.advertencias.push(`${docsSinMatrizador} documentos sin matrizador asignado`);
      }
      console.log(`üìÑ Documentos sin matrizador: ${docsSinMatrizador}`);

      // Verificar valores nulos en campos cr√≠ticos
      const docsValorNulo = await Documento.count({
        where: { 
          [Op.or]: [
            { valorFactura: null },
            { valorFactura: 0 }
          ]
        }
      });
      
      if (docsValorNulo > 0) {
        this.advertencias.push(`${docsValorNulo} documentos con valor de factura nulo o cero`);
      }
      console.log(`üí∞ Documentos sin valor: ${docsValorNulo}`);

      // Verificar documentos con fechas inconsistentes
      const docsFechaInconsistente = await Documento.count({
        where: {
          updatedAt: { [Op.lt]: sequelize.col('created_at') }
        }
      });
      
      if (docsFechaInconsistente > 0) {
        this.errores.push(`${docsFechaInconsistente} documentos con fechas inconsistentes`);
      }
      console.log(`üìÖ Documentos con fechas inconsistentes: ${docsFechaInconsistente}`);

      // Verificar consistencia en campos de pago
      const docsValoresFaltantes = await Documento.count({
        where: {
          [Op.or]: [
            { valorPagado: null },
            { valorPendiente: null },
            { valorRetenido: null }
          ]
        }
      });
      
      if (docsValoresFaltantes > 0) {
        this.errores.push(`${docsValoresFaltantes} documentos con campos de pago nulos`);
      }
      console.log(`üí≥ Documentos con campos de pago nulos: ${docsValoresFaltantes}`);

      // Verificar integridad matem√°tica b√°sica
      const docsInconsistentesBasicos = await sequelize.query(`
        SELECT COUNT(*) as total
        FROM documentos 
        WHERE ABS(valor_factura - (valor_pagado + valor_pendiente + valor_retenido)) > 0.01
        AND valor_factura IS NOT NULL
        AND estado NOT IN ('eliminado', 'nota_credito')
      `, { type: sequelize.QueryTypes.SELECT });

      const totalInconsistentesBasicos = parseInt(docsInconsistentesBasicos[0].total);
      if (totalInconsistentesBasicos > 0) {
        this.errores.push(`${totalInconsistentesBasicos} documentos con inconsistencia matem√°tica b√°sica`);
      }
      console.log(`üßÆ Documentos con matem√°tica inconsistente: ${totalInconsistentesBasicos}`);

      this.resultados.integridad = {
        docsSinMatrizador,
        docsValorNulo,
        docsFechaInconsistente,
        docsValoresFaltantes,
        totalInconsistentesBasicos
      };

    } catch (error) {
      console.error('‚ùå Error en auditor√≠a de integridad:', error);
      this.errores.push(`Error en auditor√≠a de integridad: ${error.message}`);
    }
  }

  async auditarReportesFinancieros() {
    console.log('\nüí∞ 2. AUDITANDO REPORTES FINANCIEROS (CR√çTICO)');
    console.log('-----------------------------------------------');
    
    try {
      // Obtener totales globales usando diferentes m√©todos
      const totalDocumentos = await Documento.count({
        where: { estado: { [Op.notIn]: ['eliminado', 'nota_credito'] } }
      });
      
      const totalFacturado = await Documento.sum('valorFactura', {
        where: { 
          valorFactura: { [Op.not]: null },
          estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
        }
      }) || 0;
      
      console.log(`üìä Total documentos: ${totalDocumentos}`);
      console.log(`üíµ Total facturado global: $${totalFacturado.toFixed(2)}`);

      // Auditar diferentes m√©todos de c√°lculo de "cobrado"
      await this.auditarCalculoCobrado();
      
      // Auditar por per√≠odos cr√≠ticos
      await this.auditarReportesPorPeriodo();
      
      // Auditar por matrizador (especialmente archivo)
      await this.auditarReportesPorMatrizador();

      this.resultados.financiero = {
        totalDocumentos,
        totalFacturado
      };

    } catch (error) {
      console.error('‚ùå Error en auditor√≠a financiera:', error);
      this.errores.push(`Error en auditor√≠a financiera: ${error.message}`);
    }
  }

  async auditarCalculoCobrado() {
    console.log('\nüîç Auditando m√©todos de c√°lculo de "Total Cobrado"...');
    
    try {
      // M√âTODO 1: Suma directa de valorPagado
      const cobradoMetodo1 = await Documento.sum('valorPagado', {
        where: { 
          estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
        }
      }) || 0;
      console.log(`üí≥ M√©todo 1 - Suma directa valorPagado: $${cobradoMetodo1.toFixed(2)}`);

      // M√âTODO 2: Suma condicional por estadoPago (como en controllers)
      const [cobradoMetodo2Result] = await sequelize.query(`
        SELECT COALESCE(SUM(CASE WHEN estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial') THEN valor_pagado ELSE 0 END), 0) as total
        FROM documentos
        WHERE estado NOT IN ('eliminado', 'nota_credito')
      `, { type: sequelize.QueryTypes.SELECT });
      
      const cobradoMetodo2 = parseFloat(cobradoMetodo2Result.total);
      console.log(`üí≥ M√©todo 2 - Condicional por estadoPago: $${cobradoMetodo2.toFixed(2)}`);

      // M√âTODO 3: Usando Sequelize ORM con filtro de estado (como en admin)
      const cobradoMetodo3 = await Documento.sum('valorPagado', {
        where: {
          estadoPago: { [Op.in]: ['pagado_completo', 'pagado_con_retencion', 'pago_parcial'] },
          estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
        }
      }) || 0;
      console.log(`üí≥ M√©todo 3 - ORM con filtro estadoPago: $${cobradoMetodo3.toFixed(2)}`);

      // M√âTODO 4: Total facturado menos pendiente (validaci√≥n cruzada)
      const totalFacturado = await Documento.sum('valorFactura', {
        where: { 
          valorFactura: { [Op.not]: null },
          estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
        }
      }) || 0;
      
      const totalPendiente = await Documento.sum('valorPendiente', {
        where: { estado: { [Op.notIn]: ['eliminado', 'nota_credito'] } }
      }) || 0;
      
      const totalRetenido = await Documento.sum('valorRetenido', {
        where: { estado: { [Op.notIn]: ['eliminado', 'nota_credito'] } }
      }) || 0;
      
      const cobradoMetodo4 = totalFacturado - totalPendiente - totalRetenido;
      console.log(`üí≥ M√©todo 4 - Facturado - Pendiente - Retenido: $${cobradoMetodo4.toFixed(2)}`);

      // Detectar inconsistencias cr√≠ticas
      const metodos = [
        { nombre: 'Suma directa', valor: cobradoMetodo1 },
        { nombre: 'Condicional estadoPago', valor: cobradoMetodo2 },
        { nombre: 'ORM filtrado', valor: cobradoMetodo3 },
        { nombre: 'C√°lculo indirecto', valor: cobradoMetodo4 }
      ];

      console.log('\nüìä Comparaci√≥n de m√©todos:');
      metodos.forEach((metodo, i) => {
        console.log(`   ${i + 1}. ${metodo.nombre}: $${metodo.valor.toFixed(2)}`);
      });

      // Detectar diferencias significativas (>1% o >$100)
      for (let i = 0; i < metodos.length; i++) {
        for (let j = i + 1; j < metodos.length; j++) {
          const diferencia = Math.abs(metodos[i].valor - metodos[j].valor);
          const porcentaje = metodos[i].valor > 0 ? (diferencia / metodos[i].valor) * 100 : 0;
          
          if (diferencia > 100 || porcentaje > 1) {
            this.inconsistencias.push(
              `CR√çTICO: ${metodos[i].nombre} vs ${metodos[j].nombre} - Diferencia: $${diferencia.toFixed(2)} (${porcentaje.toFixed(1)}%)`
            );
            console.log(`‚ùå INCONSISTENCIA CR√çTICA: ${metodos[i].nombre} vs ${metodos[j].nombre}`);
            console.log(`   Diferencia: $${diferencia.toFixed(2)} (${porcentaje.toFixed(1)}%)`);
          }
        }
      }

      // Verificar si alg√∫n cobrado > facturado (matem√°ticamente imposible)
      metodos.forEach(metodo => {
        if (metodo.valor > totalFacturado) {
          this.errores.push(`IMPOSIBLE: ${metodo.nombre} ($${metodo.valor.toFixed(2)}) > Total Facturado ($${totalFacturado.toFixed(2)})`);
          console.log(`‚ùå ERROR MATEM√ÅTICO: ${metodo.nombre} mayor que total facturado`);
        }
      });

    } catch (error) {
      console.error('‚ùå Error auditando c√°lculo cobrado:', error);
      this.errores.push(`Error en c√°lculo cobrado: ${error.message}`);
    }
  }

  async auditarReportesPorPeriodo() {
    console.log('\nüìÖ Auditando reportes por per√≠odo...');
    
    const periodos = [
      { 
        nombre: 'Hoy', 
        inicio: moment().startOf('day').toDate(),
        fin: moment().endOf('day').toDate()
      },
      { 
        nombre: 'Esta semana', 
        inicio: moment().startOf('week').toDate(),
        fin: moment().endOf('day').toDate()
      },
      { 
        nombre: 'Este mes', 
        inicio: moment().startOf('month').toDate(),
        fin: moment().endOf('day').toDate()
      },
      { 
        nombre: '√öltimos 30 d√≠as', 
        inicio: moment().subtract(30, 'days').startOf('day').toDate(),
        fin: moment().endOf('day').toDate()
      }
    ];

    for (const periodo of periodos) {
      console.log(`\nüìä Per√≠odo: ${periodo.nombre}`);
      
      try {
        const whereBasePeriodo = {
          created_at: {
            [Op.between]: [periodo.inicio, periodo.fin]
          },
          estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
        };

        const documentosPeriodo = await Documento.findAll({
          where: whereBasePeriodo,
          attributes: ['valorFactura', 'valorPagado', 'valorPendiente', 'valorRetenido', 'estadoPago']
        });

        const facturadoPeriodo = documentosPeriodo.reduce((sum, doc) => 
          sum + parseFloat(doc.valorFactura || 0), 0);
        
        const cobradoPeriodo = documentosPeriodo.reduce((sum, doc) => 
          sum + parseFloat(doc.valorPagado || 0), 0);

        const pendientePeriodo = documentosPeriodo.reduce((sum, doc) => 
          sum + parseFloat(doc.valorPendiente || 0), 0);

        const retenidoPeriodo = documentosPeriodo.reduce((sum, doc) => 
          sum + parseFloat(doc.valorRetenido || 0), 0);

        console.log(`  üìÑ Documentos: ${documentosPeriodo.length}`);
        console.log(`  üíµ Facturado: $${facturadoPeriodo.toFixed(2)}`);
        console.log(`  üí≥ Cobrado: $${cobradoPeriodo.toFixed(2)}`);
        console.log(`  ‚è∞ Pendiente: $${pendientePeriodo.toFixed(2)}`);
        console.log(`  üìã Retenido: $${retenidoPeriodo.toFixed(2)}`);
        
        // Verificar ecuaci√≥n b√°sica: Facturado = Cobrado + Pendiente + Retenido
        const suma = cobradoPeriodo + pendientePeriodo + retenidoPeriodo;
        const diferencia = Math.abs(facturadoPeriodo - suma);
        
        console.log(`  üßÆ Suma (C+P+R): $${suma.toFixed(2)}`);
        console.log(`  üìê Diferencia: $${diferencia.toFixed(2)}`);
        
        if (diferencia > 0.1) {
          this.errores.push(`${periodo.nombre}: Ecuaci√≥n no balancea - Diferencia: $${diferencia.toFixed(2)}`);
          console.log(`  ‚ùå ERROR: Ecuaci√≥n no balancea`);
        }
        
        if (cobradoPeriodo > facturadoPeriodo) {
          this.errores.push(`${periodo.nombre}: Cobrado > Facturado ($${cobradoPeriodo.toFixed(2)} > $${facturadoPeriodo.toFixed(2)})`);
          console.log(`  ‚ùå ERROR CR√çTICO: Cobrado mayor que facturado`);
        }

      } catch (error) {
        console.error(`‚ùå Error en per√≠odo ${periodo.nombre}:`, error);
        this.errores.push(`Error en per√≠odo ${periodo.nombre}: ${error.message}`);
      }
    }
  }

  async auditarReportesPorMatrizador() {
    console.log('\nüë• Auditando reportes por matrizador...');
    
    try {
      const matrizadores = await Matrizador.findAll({
        attributes: ['id', 'nombre', 'rol'],
        where: { activo: true }
      });

      for (const matrizador of matrizadores) {
        console.log(`\nüë§ ${matrizador.nombre} (${matrizador.rol}) - ID: ${matrizador.id}`);
        
        const documentosMatrizador = await Documento.findAll({
          where: { 
            idMatrizador: matrizador.id,
            estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
          },
          attributes: ['valorFactura', 'valorPagado', 'valorPendiente', 'valorRetenido', 'estadoPago', 'estado']
        });

        const facturadoMatrizador = documentosMatrizador.reduce((sum, doc) => 
          sum + parseFloat(doc.valorFactura || 0), 0);
        
        const cobradoMatrizador = documentosMatrizador.reduce((sum, doc) => 
          sum + parseFloat(doc.valorPagado || 0), 0);

        const pendienteMatrizador = documentosMatrizador.reduce((sum, doc) => 
          sum + parseFloat(doc.valorPendiente || 0), 0);

        console.log(`  üìÑ Documentos: ${documentosMatrizador.length}`);
        console.log(`  üíµ Facturado: $${facturadoMatrizador.toFixed(2)}`);
        console.log(`  üí≥ Cobrado: $${cobradoMatrizador.toFixed(2)}`);
        console.log(`  ‚è∞ Pendiente: $${pendienteMatrizador.toFixed(2)}`);

        if (cobradoMatrizador > facturadoMatrizador + 0.01) {
          this.errores.push(`Matrizador ${matrizador.nombre} (${matrizador.rol}): Cobrado > Facturado - $${cobradoMatrizador.toFixed(2)} > $${facturadoMatrizador.toFixed(2)}`);
          console.log(`  ‚ùå ERROR CR√çTICO: Cobrado mayor que facturado`);
          
          // Si es rol archivo, investigar m√°s
          if (matrizador.rol === 'archivo') {
            console.log(`  üîç INVESTIGANDO ROL ARCHIVO...`);
            await this.investigarUsuarioArchivo(matrizador);
          }
        }

        // Verificar si usuario archivo tiene documentos asignados
        if (matrizador.rol === 'archivo' && documentosMatrizador.length > 0) {
          this.advertencias.push(`Usuario archivo ${matrizador.nombre} tiene ${documentosMatrizador.length} documentos asignados directamente`);
          console.log(`  ‚ö†Ô∏è ATENCI√ìN: Usuario archivo con documentos asignados`);
        }
      }

    } catch (error) {
      console.error('‚ùå Error en auditor√≠a por matrizador:', error);
      this.errores.push(`Error en auditor√≠a por matrizador: ${error.message}`);
    }
  }

  async investigarUsuarioArchivo(matrizadorArchivo) {
    console.log(`    üî¨ Investigaci√≥n detallada de ${matrizadorArchivo.nombre}:`);
    
    try {
      // Obtener documentos con detalles completos
      const documentosDetallados = await sequelize.query(`
        SELECT 
          id,
          codigo_barras,
          valor_factura,
          valor_pagado,
          valor_pendiente,
          valor_retenido,
          estado_pago,
          estado,
          created_at,
          rol_usuario_creador
        FROM documentos 
        WHERE id_matrizador = :matrizadorId
        AND estado NOT IN ('eliminado', 'nota_credito')
        ORDER BY created_at DESC
        LIMIT 10
      `, {
        replacements: { matrizadorId: matrizadorArchivo.id },
        type: sequelize.QueryTypes.SELECT
      });

      console.log(`    üìã Documentos encontrados: ${documentosDetallados.length}`);
      
      documentosDetallados.forEach((doc, i) => {
        const suma = parseFloat(doc.valor_pagado || 0) + parseFloat(doc.valor_pendiente || 0) + parseFloat(doc.valor_retenido || 0);
        const diferencia = Math.abs(parseFloat(doc.valor_factura || 0) - suma);
        
        console.log(`    ${i + 1}. Doc ${doc.codigo_barras || doc.id}:`);
        console.log(`       Factura: $${parseFloat(doc.valor_factura || 0).toFixed(2)}`);
        console.log(`       Pagado: $${parseFloat(doc.valor_pagado || 0).toFixed(2)}`);
        console.log(`       Pendiente: $${parseFloat(doc.valor_pendiente || 0).toFixed(2)}`);
        console.log(`       Retenido: $${parseFloat(doc.valor_retenido || 0).toFixed(2)}`);
        console.log(`       Estado Pago: ${doc.estado_pago}`);
        console.log(`       Creado por: ${doc.rol_usuario_creador}`);
        console.log(`       Diferencia: $${diferencia.toFixed(2)}`);
        
        if (diferencia > 0.01) {
          console.log(`       ‚ùå INCONSISTENTE`);
        }
      });

    } catch (error) {
      console.error('‚ùå Error investigando usuario archivo:', error);
    }
  }

  async auditarMetodosCalculo() {
    console.log('\nüßÆ 3. AUDITANDO M√âTODOS DE C√ÅLCULO');
    console.log('-----------------------------------');
    
    try {
      // Comparar funciones calcularMetricasPeriodo de admin vs caja
      console.log('Comparando funciones calcularMetricasPeriodo...');
      
      const fechaInicio = moment().startOf('month');
      const fechaFin = moment().endOf('day');
      
      // Simular c√°lculo como en admin
      const metricsAdmin = await this.calcularMetricasComoAdmin(fechaInicio, fechaFin);
      
      // Simular c√°lculo como en caja
      const metricsCaja = await this.calcularMetricasComoCaja(fechaInicio, fechaFin);
      
      console.log('\nüìä Comparaci√≥n Admin vs Caja:');
      console.log(`Admin - Facturado: $${metricsAdmin.facturado.toFixed(2)}, Cobrado: $${metricsAdmin.cobrado.toFixed(2)}`);
      console.log(`Caja  - Facturado: $${metricsCaja.facturado.toFixed(2)}, Cobrado: $${metricsCaja.cobrado.toFixed(2)}`);
      
      const difFacturado = Math.abs(metricsAdmin.facturado - metricsCaja.facturado);
      const difCobrado = Math.abs(metricsAdmin.cobrado - metricsCaja.cobrado);
      
      if (difFacturado > 0.01) {
        this.inconsistencias.push(`Admin vs Caja - Diferencia Facturado: $${difFacturado.toFixed(2)}`);
      }
      
      if (difCobrado > 0.01) {
        this.inconsistencias.push(`Admin vs Caja - Diferencia Cobrado: $${difCobrado.toFixed(2)}`);
      }

    } catch (error) {
      console.error('‚ùå Error auditando m√©todos:', error);
      this.errores.push(`Error en m√©todos de c√°lculo: ${error.message}`);
    }
  }

  async calcularMetricasComoAdmin(fechaInicio, fechaFin) {
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    
    // Replicar l√≥gica de adminController
    const [facturacionResult] = await sequelize.query(`
      SELECT COALESCE(SUM(valor_factura), 0) as total
      FROM documentos
      WHERE created_at BETWEEN :fechaInicio AND :fechaFin
      AND numero_factura IS NOT NULL
      AND estado NOT IN ('eliminado', 'nota_credito')
    `, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    
    const [ingresosResult] = await sequelize.query(`
      SELECT COALESCE(SUM(CASE WHEN estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial') THEN valor_pagado ELSE 0 END), 0) as total
      FROM documentos
      WHERE created_at BETWEEN :fechaInicio AND :fechaFin
      AND estado NOT IN ('eliminado', 'nota_credito')
    `, {
      replacements: { fechaInicio: fechaInicioSQL, fechaFin: fechaFinSQL },
      type: sequelize.QueryTypes.SELECT
    });
    
    return {
      facturado: parseFloat(facturacionResult.total),
      cobrado: parseFloat(ingresosResult.total)
    };
  }

  async calcularMetricasComoCaja(fechaInicio, fechaFin) {
    const fechaInicioSQL = fechaInicio.format('YYYY-MM-DD HH:mm:ss');
    const fechaFinSQL = fechaFin.format('YYYY-MM-DD HH:mm:ss');
    
    // Replicar l√≥gica de cajaController
    const whereClause = {
      valor_factura: { [Op.not]: null },
      estado: { [Op.ne]: 'cancelado' },
      created_at: {
        [Op.between]: [fechaInicioSQL, fechaFinSQL]
      }
    };
    
    const totalFacturado = await Documento.sum('valor_factura', {
      where: whereClause
    }) || 0;
    
    const totalCobrado = await Documento.sum('valor_pagado', {
      where: {
        ...whereClause,
        estado_pago: { [Op.in]: ['pagado_completo', 'pagado_con_retencion', 'pago_parcial'] }
      }
    }) || 0;
    
    return {
      facturado: totalFacturado,
      cobrado: totalCobrado
    };
  }

  async auditarComparacionReportes() {
    console.log('\nüîÑ 4. AUDITANDO REPORTES ADMIN VS CAJA');
    console.log('--------------------------------------');
    
    // Esta funci√≥n compara si admin y caja muestran los mismos totales
    // para los mismos per√≠odos y filtros
    
    console.log('‚úÖ Implementaci√≥n pendiente - requiere an√°lisis de vistas');
  }

  async auditarFiltrosPorRol() {
    console.log('\nüîê 5. AUDITANDO FILTROS POR ROL');
    console.log('-------------------------------');
    
    try {
      // Verificar que rol archivo no contamine c√°lculos
      const usuariosArchivo = await Matrizador.findAll({
        where: { rol: 'archivo', activo: true }
      });

      console.log(`üìÅ Usuarios con rol archivo: ${usuariosArchivo.length}`);

      for (const usuario of usuariosArchivo) {
        console.log(`üìÅ ${usuario.nombre} (ID: ${usuario.id})`);
        
        // Verificar si aparece en queries de reportes donde no deber√≠a
        const documentosAsignados = await Documento.count({
          where: { 
            idMatrizador: usuario.id,
            estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
          }
        });
        
        console.log(`  üìÑ Documentos asignados: ${documentosAsignados}`);
        
        if (documentosAsignados > 0) {
          this.advertencias.push(`Usuario archivo ${usuario.nombre} aparece en reportes con ${documentosAsignados} documentos`);
          
          // Verificar si estos documentos afectan totales
          const valorTotalArchivo = await Documento.sum('valorFactura', {
            where: { 
              idMatrizador: usuario.id,
              estado: { [Op.notIn]: ['eliminado', 'nota_credito'] }
            }
          }) || 0;
          
          if (valorTotalArchivo > 0) {
            this.advertencias.push(`Usuario archivo ${usuario.nombre} suma $${valorTotalArchivo.toFixed(2)} a los totales`);
            console.log(`  üí∞ Valor total en reportes: $${valorTotalArchivo.toFixed(2)}`);
          }
        }
      }

    } catch (error) {
      console.error('‚ùå Error auditando filtros por rol:', error);
      this.errores.push(`Error en filtros por rol: ${error.message}`);
    }
  }

  async auditarQueriesSQL() {
    console.log('\nüîç 6. AUDITANDO QUERIES SQL ESPEC√çFICAS');
    console.log('---------------------------------------');
    
    try {
      // Probar queries problem√°ticas directamente
      console.log('Probando query de reporte financiero admin...');
      
      const [queryAdmin] = await sequelize.query(`
        SELECT 
          COUNT(*) as total_docs,
          COALESCE(SUM(valor_factura), 0) as total_facturado,
          COALESCE(SUM(CASE WHEN estado_pago IN ('pagado_completo', 'pagado_con_retencion', 'pago_parcial') THEN valor_pagado ELSE 0 END), 0) as total_cobrado
        FROM documentos
        WHERE estado NOT IN ('eliminado', 'nota_credito')
        AND valor_factura IS NOT NULL
      `, { type: sequelize.QueryTypes.SELECT });

      console.log(`üìä Query Admin - Docs: ${queryAdmin.total_docs}, Facturado: $${parseFloat(queryAdmin.total_facturado).toFixed(2)}, Cobrado: $${parseFloat(queryAdmin.total_cobrado).toFixed(2)}`);

      console.log('Probando query de reporte financiero caja...');
      
      const [queryCaja] = await sequelize.query(`
        SELECT 
          COUNT(*) as total_docs,
          COALESCE(SUM(valor_factura), 0) as total_facturado,
          COALESCE(SUM(valor_pagado), 0) as total_cobrado_directo
        FROM documentos
        WHERE estado != 'cancelado'
        AND valor_factura IS NOT NULL
      `, { type: sequelize.QueryTypes.SELECT });

      console.log(`üìä Query Caja - Docs: ${queryCaja.total_docs}, Facturado: $${parseFloat(queryCaja.total_facturado).toFixed(2)}, Cobrado: $${parseFloat(queryCaja.total_cobrado_directo).toFixed(2)}`);

      // Comparar resultados
      const difFacturado = Math.abs(parseFloat(queryAdmin.total_facturado) - parseFloat(queryCaja.total_facturado));
      const difCobrado = Math.abs(parseFloat(queryAdmin.total_cobrado) - parseFloat(queryCaja.total_cobrado_directo));

      if (difFacturado > 0.01) {
        this.inconsistencias.push(`Queries SQL - Diferencia Facturado: $${difFacturado.toFixed(2)}`);
      }

      if (difCobrado > 0.01) {
        this.inconsistencias.push(`Queries SQL - Diferencia Cobrado: $${difCobrado.toFixed(2)}`);
      }

      // Verificar query espec√≠fica problem√°tica
      console.log('Verificando casos donde cobrado > facturado...');
      
      const casos_problematicos = await sequelize.query(`
        SELECT 
          id,
          codigo_barras,
          valor_factura,
          valor_pagado,
          valor_pendiente,
          valor_retenido,
          estado_pago,
          id_matrizador,
          (valor_pagado + valor_pendiente + valor_retenido) as suma_total,
          ABS(valor_factura - (valor_pagado + valor_pendiente + valor_retenido)) as diferencia
        FROM documentos
        WHERE (valor_pagado + valor_pendiente + valor_retenido) > valor_factura + 0.01
        AND estado NOT IN ('eliminado', 'nota_credito')
        ORDER BY diferencia DESC
        LIMIT 10
      `, { type: sequelize.QueryTypes.SELECT });

      if (casos_problematicos.length > 0) {
        console.log(`‚ùå ENCONTRADOS ${casos_problematicos.length} CASOS PROBLEM√ÅTICOS:`);
        casos_problematicos.forEach((caso, i) => {
          console.log(`   ${i + 1}. Doc ${caso.codigo_barras || caso.id}:`);
          console.log(`      Factura: $${parseFloat(caso.valor_factura).toFixed(2)}`);
          console.log(`      Suma total: $${parseFloat(caso.suma_total).toFixed(2)}`);
          console.log(`      Diferencia: $${parseFloat(caso.diferencia).toFixed(2)}`);
          console.log(`      Matrizador: ${caso.id_matrizador}`);
        });
        
        this.errores.push(`${casos_problematicos.length} documentos con suma de pagos mayor a factura`);
      }

    } catch (error) {
      console.error('‚ùå Error auditando queries SQL:', error);
      this.errores.push(`Error en queries SQL: ${error.message}`);
    }
  }

  generarReporteFinal() {
    console.log('\nüìã REPORTE FINAL DE AUDITOR√çA');
    console.log('==============================');
    console.log(`Fecha: ${moment().format('DD/MM/YYYY HH:mm:ss')}`);
    
    console.log(`\n‚ùå ERRORES CR√çTICOS (${this.errores.length}):`);
    if (this.errores.length === 0) {
      console.log('   ‚úÖ No se encontraron errores cr√≠ticos');
    } else {
      this.errores.forEach((error, i) => {
        console.log(`   ${i + 1}. ${error}`);
      });
    }

    console.log(`\n‚ö†Ô∏è ADVERTENCIAS (${this.advertencias.length}):`);
    if (this.advertencias.length === 0) {
      console.log('   ‚úÖ No se encontraron advertencias');
    } else {
      this.advertencias.forEach((adv, i) => {
        console.log(`   ${i + 1}. ${adv}`);
      });
    }

    console.log(`\nüîç INCONSISTENCIAS (${this.inconsistencias.length}):`);
    if (this.inconsistencias.length === 0) {
      console.log('   ‚úÖ No se encontraron inconsistencias');
    } else {
      this.inconsistencias.forEach((inc, i) => {
        console.log(`   ${i + 1}. ${inc}`);
      });
    }

    console.log('\nüéØ DIAGN√ìSTICO:');
    if (this.errores.length > 0) {
      console.log('   üö® SISTEMA TIENE ERRORES CR√çTICOS - Revisi√≥n inmediata requerida');
    }
    if (this.inconsistencias.length > 0) {
      console.log('   ‚ö†Ô∏è M√âTODOS DE C√ÅLCULO INCONSISTENTES - Unificaci√≥n necesaria');
    }
    if (this.advertencias.length > 0) {
      console.log('   üìù CONFIGURACIONES A REVISAR - No cr√≠ticas pero importantes');
    }
    if (this.errores.length === 0 && this.inconsistencias.length === 0) {
      console.log('   ‚úÖ SISTEMA MATEM√ÅTICAMENTE CONSISTENTE');
    }

    console.log('\nüéØ RECOMENDACIONES INMEDIATAS:');
    
    if (this.errores.some(e => e.includes('Cobrado > Facturado'))) {
      console.log('   1. üö® CR√çTICO: Corregir documentos donde cobrado > facturado');
      console.log('      ‚Üí Ejecutar script de correcci√≥n de doble conteo');
      console.log('      ‚Üí Revisar l√≥gica de c√°lculo de valorPagado');
    }
    
    if (this.inconsistencias.some(i => i.includes('M√©todo'))) {
      console.log('   2. üîß UNIFICAR m√©todos de c√°lculo entre admin y caja');
      console.log('      ‚Üí Usar misma funci√≥n calcularMetricasPeriodo');
      console.log('      ‚Üí Estandarizar queries SQL');
    }
    
    if (this.advertencias.some(a => a.includes('archivo'))) {
      console.log('   3. üîç REVISAR configuraci√≥n de rol archivo');
      console.log('      ‚Üí Verificar que no contamina reportes');
      console.log('      ‚Üí Actualizar filtros de consultas');
    }
    
    if (this.errores.some(e => e.includes('inconsistencia matem√°tica'))) {
      console.log('   4. üßÆ CORREGIR documentos con matem√°tica inconsistente');
      console.log('      ‚Üí Recalcular valorPendiente = valorFactura - valorPagado - valorRetenido');
      console.log('      ‚Üí Validar estados de pago');
    }

    console.log('\nüìä PR√ìXIMOS PASOS:');
    console.log('   1. Ejecutar script de correcci√≥n automatizada');
    console.log('   2. Unificar funciones de c√°lculo en adminController y cajaController');
    console.log('   3. Implementar validaciones en modelo Documento');
    console.log('   4. Crear tests automatizados para reportes');
    console.log('   5. Configurar auditor√≠a peri√≥dica (diaria/semanal)');

    console.log('\n‚úÖ AUDITOR√çA COMPLETADA');
    console.log(`Total de verificaciones: ${this.errores.length + this.advertencias.length + this.inconsistencias.length}`);
    console.log(`Estado: ${this.errores.length > 0 ? 'CR√çTICO' : this.inconsistencias.length > 0 ? 'ATENCI√ìN' : 'SALUDABLE'}`);
  }
}

// Ejecutar auditor√≠a si se llama directamente
if (require.main === module) {
  const auditoria = new AuditoriaReportes();
  auditoria.ejecutarAuditoria()
    .then(() => {
      console.log('\nüéâ Auditor√≠a finalizada exitosamente');
      process.exit(0);
    })
    .catch(err => {
      console.error('\nüí• Error en auditor√≠a:', err);
      process.exit(1);
    });
}

module.exports = AuditoriaReportes; 